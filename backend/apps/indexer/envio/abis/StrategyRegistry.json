{"abi":[{"type":"constructor","inputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"UPGRADE_INTERFACE_VERSION","inputs":[],"outputs":[{"name":"","type":"string","internalType":"string"}],"stateMutability":"view"},{"type":"function","name":"createStrategy","inputs":[{"name":"delegator","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"},{"name":"tokens","type":"address[]","internalType":"address[]"},{"name":"weights","type":"uint256[]","internalType":"uint256[]"},{"name":"rebalanceInterval","type":"uint256","internalType":"uint256"},{"name":"name","type":"string","internalType":"string"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"deleteStrategy","inputs":[{"name":"delegator","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getAllUserStrategies","inputs":[{"name":"user","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"tuple[]","internalType":"struct StrategyLibrary.Strategy[]","components":[{"name":"id","type":"uint256","internalType":"uint256"},{"name":"owner","type":"address","internalType":"address"},{"name":"delegator","type":"address","internalType":"address"},{"name":"tokens","type":"address[]","internalType":"address[]"},{"name":"weights","type":"uint256[]","internalType":"uint256[]"},{"name":"rebalanceInterval","type":"uint256","internalType":"uint256"},{"name":"lastRebalanceTime","type":"uint256","internalType":"uint256"},{"name":"isActive","type":"bool","internalType":"bool"},{"name":"name","type":"string","internalType":"string"}]}],"stateMutability":"view"},{"type":"function","name":"getStrategy","inputs":[{"name":"user","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"strategy","type":"tuple","internalType":"struct StrategyLibrary.Strategy","components":[{"name":"id","type":"uint256","internalType":"uint256"},{"name":"owner","type":"address","internalType":"address"},{"name":"delegator","type":"address","internalType":"address"},{"name":"tokens","type":"address[]","internalType":"address[]"},{"name":"weights","type":"uint256[]","internalType":"uint256[]"},{"name":"rebalanceInterval","type":"uint256","internalType":"uint256"},{"name":"lastRebalanceTime","type":"uint256","internalType":"uint256"},{"name":"isActive","type":"bool","internalType":"bool"},{"name":"name","type":"string","internalType":"string"}]}],"stateMutability":"view"},{"type":"function","name":"getUserStrategyCount","inputs":[{"name":"user","type":"address","internalType":"address"}],"outputs":[{"name":"count","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getUserStrategyIds","inputs":[{"name":"user","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"view"},{"type":"function","name":"getVersion","inputs":[],"outputs":[{"name":"","type":"string","internalType":"string"}],"stateMutability":"pure"},{"type":"function","name":"initialize","inputs":[{"name":"_owner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"pauseStrategy","inputs":[{"name":"delegator","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"proxiableUUID","inputs":[],"outputs":[{"name":"","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"rebalanceExecutor","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"resumeStrategy","inputs":[{"name":"delegator","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setRebalanceExecutor","inputs":[{"name":"_executor","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"strategies","inputs":[{"name":"","type":"address","internalType":"address"},{"name":"","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"id","type":"uint256","internalType":"uint256"},{"name":"owner","type":"address","internalType":"address"},{"name":"delegator","type":"address","internalType":"address"},{"name":"rebalanceInterval","type":"uint256","internalType":"uint256"},{"name":"lastRebalanceTime","type":"uint256","internalType":"uint256"},{"name":"isActive","type":"bool","internalType":"bool"},{"name":"name","type":"string","internalType":"string"}],"stateMutability":"view"},{"type":"function","name":"transferOwnership","inputs":[{"name":"newOwner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateLastRebalanceTime","inputs":[{"name":"user","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateStrategy","inputs":[{"name":"delegator","type":"address","internalType":"address"},{"name":"strategyId","type":"uint256","internalType":"uint256"},{"name":"tokens","type":"address[]","internalType":"address[]"},{"name":"weights","type":"uint256[]","internalType":"uint256[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"upgradeToAndCall","inputs":[{"name":"newImplementation","type":"address","internalType":"address"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"userStrategyCount","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"userStrategyIds","inputs":[{"name":"","type":"address","internalType":"address"},{"name":"","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"event","name":"Initialized","inputs":[{"name":"version","type":"uint64","indexed":false,"internalType":"uint64"}],"anonymous":false},{"type":"event","name":"LastRebalanceTimeUpdated","inputs":[{"name":"delegator","type":"address","indexed":true,"internalType":"address"},{"name":"strategyId","type":"uint256","indexed":true,"internalType":"uint256"},{"name":"timestamp","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"OwnershipTransferred","inputs":[{"name":"previousOwner","type":"address","indexed":true,"internalType":"address"},{"name":"newOwner","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"event","name":"RebalanceExecutorUpdated","inputs":[{"name":"oldExecutor","type":"address","indexed":true,"internalType":"address"},{"name":"newExecutor","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"event","name":"StrategyCreated","inputs":[{"name":"delegator","type":"address","indexed":true,"internalType":"address"},{"name":"owner","type":"address","indexed":true,"internalType":"address"},{"name":"strategyId","type":"uint256","indexed":true,"internalType":"uint256"},{"name":"name","type":"string","indexed":false,"internalType":"string"},{"name":"tokens","type":"address[]","indexed":false,"internalType":"address[]"},{"name":"weights","type":"uint256[]","indexed":false,"internalType":"uint256[]"}],"anonymous":false},{"type":"event","name":"StrategyDeleted","inputs":[{"name":"delegator","type":"address","indexed":true,"internalType":"address"},{"name":"strategyId","type":"uint256","indexed":true,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"StrategyPaused","inputs":[{"name":"delegator","type":"address","indexed":true,"internalType":"address"},{"name":"strategyId","type":"uint256","indexed":true,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"StrategyResumed","inputs":[{"name":"delegator","type":"address","indexed":true,"internalType":"address"},{"name":"strategyId","type":"uint256","indexed":true,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"StrategyUpdated","inputs":[{"name":"delegator","type":"address","indexed":true,"internalType":"address"},{"name":"strategyId","type":"uint256","indexed":true,"internalType":"uint256"},{"name":"tokens","type":"address[]","indexed":false,"internalType":"address[]"},{"name":"weights","type":"uint256[]","indexed":false,"internalType":"uint256[]"}],"anonymous":false},{"type":"event","name":"Upgraded","inputs":[{"name":"implementation","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"error","name":"AddressEmptyCode","inputs":[{"name":"target","type":"address","internalType":"address"}]},{"type":"error","name":"ERC1967InvalidImplementation","inputs":[{"name":"implementation","type":"address","internalType":"address"}]},{"type":"error","name":"ERC1967NonPayable","inputs":[]},{"type":"error","name":"FailedCall","inputs":[]},{"type":"error","name":"InvalidInitialization","inputs":[]},{"type":"error","name":"InvalidStrategyId","inputs":[]},{"type":"error","name":"NotADeleGator","inputs":[]},{"type":"error","name":"NotAuthorized","inputs":[]},{"type":"error","name":"NotInitializing","inputs":[]},{"type":"error","name":"OnlyRebalanceExecutor","inputs":[]},{"type":"error","name":"OnlyStrategyOwner","inputs":[]},{"type":"error","name":"OwnableInvalidOwner","inputs":[{"name":"owner","type":"address","internalType":"address"}]},{"type":"error","name":"OwnableUnauthorizedAccount","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"StrategyAlreadyExists","inputs":[]},{"type":"error","name":"StrategyNotFound","inputs":[]},{"type":"error","name":"UUPSUnauthorizedCallContext","inputs":[]},{"type":"error","name":"UUPSUnsupportedProxiableUUID","inputs":[{"name":"slot","type":"bytes32","internalType":"bytes32"}]}],"bytecode":{"object":"0x60a080604052346100cc57306080527ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a009081549060ff8260401c166100bd57506001600160401b036002600160401b031982821601610078575b6040516121e290816100d182396080518181816113df01526114980152f35b6001600160401b031990911681179091556040519081527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f8080610059565b63f92ee8a960e01b8152600490fd5b5f80fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c9081630d8e6e2c146119d05750806329caf0bb146117655780634648f9031461164f5780634f1ef2861461144957806352d1902d146113cd5780636c451e4f14611376578063715018a61461130f5780637323d1dc1461129d578063751c4c8314610b73578063787cc3e8146109645780638da5cb5b1461092f5780639048086f146108705780639f8f3244146107ce578063a8754aa214610712578063ad3cb1cc146106c8578063b79f8a8b14610471578063c4d66de81461033a578063ce6e13ff1461028c578063d77ab72d14610263578063d88490d01461023b578063f2fde38b1461020e578063f405e5b8146101565763fe25333a1461011b575f80fd5b34610153576020366003190112610153576020906040906001600160a01b03610142611a4d565b168152600283522054604051908152f35b80fd5b503461015357604036600319011261015357610170611a4d565b600354602435916001600160a01b0391821633036101fc5716808352826020526040832082845260205260408320805415806101f0575b6101de576006429101557f07264369268ed39a83671d08cb89484ddb5660037f2e7ec2ae6917e44427fa426020604051428152a380f35b604051632df15a4160e11b8152600490fd5b506003810154156101a7565b6040516303c4eecf60e21b8152600490fd5b50346101535760203660031901126101535761023861022b611a4d565b610233611fbf565b611f4e565b80f35b5034610153576020366003190112610153576020906040906001600160a01b03610142611a4d565b50346101535780600319360112610153576003546040516001600160a01b039091168152602090f35b5034610153576020366003190112610153576102a6611a4d565b6102ae611fbf565b6001600160a01b0390811690811561030257600354826bffffffffffffffffffffffff60a01b821617600355167f24bfaf52118d10c0defabb4f43e353b9c8aa2b4eb66946b56f272a5745dfb58c8380a380f35b60405162461bcd60e51b815260206004820152601060248201526f24b73b30b634b21032bc32b1baba37b960811b6044820152606490fd5b503461015357602036600319011261015357610354611a4d565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090815460ff8160401c1615916001600160401b03821680159081610469575b600114908161045f575b159081610456575b506104445767ffffffffffffffff19821660011784556103d79183610425575b506103cf6120e8565b6102336120e8565b6103df6120e8565b6103e7575080f35b68ff00000000000000001981541690557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a180f35b68ffffffffffffffffff1916680100000000000000011784555f6103c6565b60405163f92ee8a960e01b8152600490fd5b9050155f6103a6565b303b15915061039e565b849150610394565b50346101535760803660031901126101535761048b611a4d565b602435906001600160401b036044358181116106c4576104af903690600401611c5a565b90916064358181116106c0576104c9903690600401611c5a565b9060018060a01b038096169586895260209389855260408a20898b52855260408a20805415806106b4575b6101de57600192806001830154163314158061069a575b610688578b73__$dba9e2f2db071a4fcbbef338f63ec817de$__803b1561068457818789928c8e610552604051968795869485946323a7592960e11b865260048601611e82565b03915af4801561067957610661575b5050600382019083891161064d576105798983611d9b565b89918d52878d208d925b8a841061062d5750505050600401908411610619576105a28482611d9b565b8952838920828a5b858110610608575050505091610602917f6db76c8a3889c0731b3752f6ea9abcd361cf982366fdde8d31bc729190a799369594936105f5604051968796604088526040880191611ef7565b9285840390860152611e5e565b0390a380f35b8135838201559086019083016105aa565b634e487b7160e01b8a52604160045260248afd5b8035938385168503610649578a88920194818401550192610583565b8f80fd5b634e487b7160e01b8d52604160045260248dfd5b61066a90611b91565b610675578b5f610561565b8b80fd5b6040513d84823e3d90fd5b5080fd5b60405163ea8e4eb560e01b8152600490fd5b50805f8051602061218d833981519152541633141561050b565b506003810154156104f4565b8680fd5b8480fd5b503461015357806003193601126101535761070e6040516106e881611ba4565b60058152640352e302e360dc1b6020820152604051918291602083526020830190611a0f565b0390f35b50346101535760403660031901126101535761072c611a4d565b6001600160a01b03908116808352602083815260408085206024358087529252842080549193909115806107c2575b6101de578060018301541633141590816107a7575b5061068857600701805460ff191690557f6fe898767072debe4012739f5364c570c493a82c0c58270b3724b1a1700708d38380a380f35b90505f8051602061218d83398151915254163314155f610770565b5060038201541561075b565b50346101535760403660031901126101535760406107ea611a4d565b9160018060a01b0380931681528060205281812060243582526020522061070e815491836001820154169360028201541690600581015460068201549061083b600860ff6007860154169401611cc2565b9360405197889788526020880152604087015260608601526080850152151560a084015260e060c084015260e0830190611a0f565b50346101535760403660031901126101535761088a611a4d565b6001600160a01b0390811680835260208381526040808520602435808752925284208054919390911580610923575b6101de57806001830154163314159081610908575b5061068857600701805460ff191660011790557f5bdc7734939384f886d0744037b20922c8b610626171a851c34e94001faf0ccb8380a380f35b90505f8051602061218d83398151915254163314155f6108ce565b506003820154156108b9565b50346101535780600319360112610153575f8051602061218d833981519152546040516001600160a01b039091168152602090f35b503461015357602080600319360112610684576001600160a01b0380610988611a4d565b169283815260019182845261099f60408320611e10565b8051956109c46109ae88611ee0565b976109bc604051998a611bbf565b808952611ee0565b601f1901845b818110610b575750508484905b610a3d575b5050505060405192808401908085528551809252604085018160408460051b880101970193905b838210610a105786880387f35b90919293948380610a2c839a603f198b82030186528951611a77565b999701959493919091019101610a03565b908291869896949351811015610b4e57849082875286895260408720610a638286611f3a565b51885289526040872060405190610a7982611b61565b805482528684820154168b8301528660028201541660408301526003810160405190818d82549182815201918c528d808d20918d915b818310610b3457505050509181610acd600893610b0c950382611bbf565b6060850152610ade60048201611e10565b6080850152600581015460a0850152600681015460c085015260ff600782015416151560e085015201611cc2565b610100820152610b1c828a611f3a565b52610b278189611f3a565b50019091929395976109d7565b83548d1685528d999401939283019291909101908f610aaf565b509694966109dc565b8790610b64999799611dcd565b82828a010152019795976109ca565b50346111e45760c03660031901126111e457610b8d611a4d565b6044356001600160401b0381116111e457610bac903690600401611c5a565b906064356001600160401b0381116111e457610bcc903690600401611c5a565b60a492919235916001600160401b0383116111e457366023840112156111e4576001600160401b038360040135116111e4573660248460040135850101116111e457610c1786612026565b1561128b576001600160a01b03610c2d87612072565b16948515611246578533141580611225575b6106885760018060a01b0387165f525f60205260405f206024355f5260205260405f2054158015906111fa575b6111e85773__$dba9e2f2db071a4fcbbef338f63ec817de$__803b156111e4575f60405180926323a7592960e11b82528180610cae898c898b60048601611e82565b03915af480156111d9576111c6575b506084351561118e5783600401351561115a57604051610cdc81611b61565b6024358152602081018790526001600160a01b0388166040820152610d0082611ee0565b610d0d6040519182611bbf565b82815260208101368460051b86011161113e5784905b8460051b860182106111425750506060820152610d3f84611ee0565b610d4c6040519182611bbf565b84815260208101368660051b89011161113e5787905b8660051b8901821061112e575050608082015260843560a08201524260c0820152600160e0820152610d9c36866004013560248801611bfb565b6101008201526001600160a01b038881168a5260208a81526040808c206024358d528252808c2084518155918401516001830180549185166001600160a01b0319928316179055908401516002830180549190941691161790915560608201518051919291906001600160401b0382116110fd57602090610e208360038701611d9b565b01600384018c5260208c208c5b838110611111575050505060808101518051906001600160401b0382116110fd57602090610e5e8360048701611d9b565b01600484018c5260208c208c5b8381106110e957505050508060a0610100920151600584015560c081015160068401556007830160e0820151151560ff8019835416911617905501518051906001600160401b0382116110d557610ec56008840154611c8a565b601f8111611097575b50602090601f831160011461102b57600892918c9183611020575b50508160011b915f199060031b1c1916179101555b6001600160a01b0387168852600160205260408820805490600160401b8210156106195781610f35916001610f4e94018155611c31565b6024359082549060031b91821b915f19901b1916179055565b6001600160a01b038716885260026020526040882080545f19811461100c577ff027eb8b70490a503951d126e80b22a66771a2f115457bbfa215e214b920429a959361100693608096936001610fe8940190556040519687966060885280600401356060890152806004013560248201838a01376004013587810182018e9052601f01601f19168701878103820160208901520191611ef7565b8381036040850152602435986001600160a01b031696909190611e5e565b0390a480f35b634e487b7160e01b8a52601160045260248afd5b015190505f80610ee9565b90600884018c5260208c20918c5b601f198516811061107f5750918391600193600895601f19811610611067575b505050811b01910155610efe565b01515f1960f88460031b161c191690555f8080611059565b91926020600181928685015181550194019201611039565b6110c590600885018d5260208d20601f850160051c810191602086106110cb575b601f0160051c0190611d64565b5f610ece565b90915081906110b8565b634e487b7160e01b8b52604160045260248bfd5b600190602084519401938184015501610e6b565b634e487b7160e01b8c52604160045260248cfd5b82516001600160a01b031681830155602090920191600101610e2d565b8135815260209182019101610d62565b8a80fd5b6020809161114f84611a63565b815201910190610d23565b60405162461bcd60e51b815260206004820152600c60248201526b496e76616c6964206e616d6560a01b6044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201526f125b9d985b1a59081a5b9d195c9d985b60821b6044820152606490fd5b6111d1919850611b91565b5f965f610cbd565b6040513d5f823e3d90fd5b5f80fd5b60405163c45546f760e01b8152600490fd5b5060018060a01b0387165f525f60205260405f206024355f52602052600360405f2001541515610c6c565b505f8051602061218d833981519152546001600160a01b0316331415610c3f565b60405162461bcd60e51b815260206004820152601760248201527f496e76616c69642044656c654761746f72206f776e65720000000000000000006044820152606490fd5b6040516305a18a2360e31b8152600490fd5b346111e4576020806003193601126111e4576001600160a01b036112bf611a4d565b165f52600190600181526112d560405f20611e10565b9160405191808301818452845180915281604085019501915f5b8281106112fc5785870386f35b83518752958101959281019284016112ef565b346111e4575f3660031901126111e457611327611fbf565b5f8051602061218d83398151915280546001600160a01b031981169091555f906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b346111e45760403660031901126111e45761138f611a4d565b6001600160a01b03165f908152600160205260409020805460243591908210156111e4576020916113bf91611c31565b90546040519160031b1c8152f35b346111e4575f3660031901126111e4577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036114375760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b60405163703e46dd60e11b8152600490fd5b60403660031901126111e45761145d611a4d565b6024356001600160401b0381116111e457366023820112156111e45761148d903690602481600401359101611bfb565b906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116308114908115611621575b50611437576114d1611fbf565b8116906040516352d1902d60e01b8152602081600481865afa5f91816115ed575b5061151057604051634c9c8ce360e01b815260048101849052602490fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc929192908181036115d55750823b156115bc5780546001600160a01b03191682179055604051907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156115a357505f808360206115a195519101845af461159b611ff7565b91612129565b005b915050346115ad57005b63b398979f60e01b8152600490fd5b604051634c9c8ce360e01b815260048101839052602490fd5b60249060405190632a87526960e21b82526004820152fd5b9091506020813d602011611619575b8161160960209383611bbf565b810103126111e4575190856114f2565b3d91506115fc565b9050817f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc54161415846114c4565b346111e45760403660031901126111e457611668611a4d565b611670611dcd565b5060018060a01b038091165f5260205f815260405f206024355f52815260405f206040519261169e84611b61565b815484526001908060018401541684860152806002840154166040860152600383019060405192838684549182815201935f52865f20925f905b8883831061174e578a9061173460088b8b6116f5818d0382611bbf565b606086015261170660048201611e10565b6080860152600581015460a0860152600681015460c086015260ff600782015416151560e086015201611cc2565b61010083015261070e604051928284938452830190611a77565b8554821687529095019493830193908301906116d8565b346111e45760403660031901126111e45761177e611a4d565b602480359060018060a01b0380931690815f526020905f825260405f20845f52825260405f2094855415806119c4575b6101de57806001809701541633141590816119a9575b50610688578490835f525f835260405f20855f52835260405f205f81555f838201555f600282015560086003916117fd60038201611d7a565b61180960048201611d7a565b5f60058201555f60068201555f6007820155016118268154611c8a565b908161196e575b5050909150835f5285835260405f20865f905b61189e575b50505050816002929394505f525260405f208054801561188a575f190190557f4dcd504f23c1c204f965486c526a1e35cfb215bb4823dd1be0a172277bb1b3455f80a3005b634e487b7160e01b5f52601160045260245ffd5b81548082101561196857876118b38385611c31565b905490861b1c146118c75750870187611840565b9091929397505f1991828201918211611955576118f76118ea61190f9386611c31565b905490871b1c9185611c31565b90919082549060031b91821b915f19901b1916179055565b81549687156119425750806002959697019261192b8484611c31565b81939154921b1b1916905555839291858080611845565b634e487b7160e01b5f9081526031600452fd5b88634e487b7160e01b5f5260116004525ffd5b50611845565b81601f5f93116001146119855750555b878061182d565b9080839182526119a2601f898420940160051c8401888501611d64565b555561197e565b90505f8051602061218d8339815191525416331415866117c4565b506003860154156117ae565b346111e4575f3660031901126111e457806119ed61070e92611ba4565b60058152640312e302e360dc1b60208201526040519182916020835260208301905b91908251928382525f5b848110611a39575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201611a19565b600435906001600160a01b03821682036111e457565b35906001600160a01b03821682036111e457565b919091610120908184019381518152602094858301519060018060a01b0380921687840152816040850151166040840152606084015194606084015284518091528661014084019501915f905b88838310611b4757505050505060808201519281810360808301528580855192838152019401905f5b818110611b3357505050611b3093945060a082015160a082015260c082015160c082015260e0820151151560e08201526101008092015191818403910152611a0f565b90565b825186529487019491870191600101611aed565b845182168852968701969093019260019190910190611ac4565b61012081019081106001600160401b03821117611b7d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b038111611b7d57604052565b604081019081106001600160401b03821117611b7d57604052565b90601f801991011681019081106001600160401b03821117611b7d57604052565b6001600160401b038111611b7d57601f01601f191660200190565b929192611c0782611be0565b91611c156040519384611bbf565b8294818452818301116111e4578281602093845f960137010152565b8054821015611c46575f5260205f2001905f90565b634e487b7160e01b5f52603260045260245ffd5b9181601f840112156111e4578235916001600160401b0383116111e4576020808501948460051b0101116111e457565b90600182811c92168015611cb8575b6020831014611ca457565b634e487b7160e01b5f52602260045260245ffd5b91607f1691611c99565b9060405191825f8254611cd481611c8a565b908184526020946001916001811690815f14611d425750600114611d04575b505050611d0292500383611bbf565b565b5f90815285812095935091905b818310611d2a575050611d0293508201015f8080611cf3565b85548884018501529485019487945091830191611d11565b92505050611d0294925060ff191682840152151560051b8201015f8080611cf3565b818110611d6f575050565b5f8155600101611d64565b80545f825580611d88575050565b611d02915f5260205f2090810190611d64565b90600160401b8111611b7d57815490808355818110611db957505050565b611d02925f5260205f209182019101611d64565b60405190611dda82611b61565b6060610100835f81525f60208201525f604082015282808201528260808201525f60a08201525f60c08201525f60e08201520152565b90604051918281549182825260209260208301915f5260205f20935f905b828210611e4457505050611d0292500383611bbf565b855484526001958601958895509381019390910190611e2e565b81835290916001600160fb1b0383116111e45760209260051b809284830137010190565b949391949290928560408201604083525260608101935f965b808810611eb7575050611b309495506020818503910152611e5e565b90946001906001600160a01b03611ecd88611a63565b1681526020809101960197019690611e9b565b6001600160401b038111611b7d5760051b60200190565b9190808252602080920192915f5b828110611f13575050505090565b909192938280600192838060a01b03611f2b89611a63565b16815201950193929101611f05565b8051821015611c465760209160051b010190565b6001600160a01b03908116908115611fa7575f8051602061218d83398151915280546001600160a01b031981168417909155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b604051631e4fbdf760e01b81525f6004820152602490fd5b5f8051602061218d833981519152546001600160a01b03163303611fdf57565b60405163118cdaa760e01b8152336004820152602490fd5b3d15612021573d9061200882611be0565b916120166040519384611bbf565b82523d5f602084013e565b606090565b803b1561206d575f80916040516020810190638da5cb5b60e01b82526004815261204f81611ba4565b51915afa61205b611ff7565b81612064575090565b60209150511490565b505f90565b803b1561206d575f80916040516020810190638da5cb5b60e01b82526004815261209b81611ba4565b51915afa6120a7611ff7565b90806120dd575b6120b757505f90565b6020818051810103126111e457602001516001600160a01b038116908190036111e45790565b5060208151146120ae565b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c161561211757565b604051631afcd79f60e31b8152600490fd5b90612150575080511561213e57602081519101fd5b60405163d6bda27560e01b8152600490fd5b81511580612183575b612161575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b1561215956fe9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300a26469706673582212201db3a3a3b8e97357214dfbd0d89ba13875545553021b9d10fde720fdba279c9164736f6c63430008170033","sourceMap":"909:10924:82:-:0;;;;;;;1171:4:34;1163:13;;3147:66:33;909:10924:82;;;;;;;;;7894:76:33;;-1:-1:-1;;;;;;;;;;;;909:10924:82;;;7983:34:33;7979:146;;-1:-1:-1;909:10924:82;;;;;;;;1163:13:34;909:10924:82;;;;;;;;;;;7979:146:33;-1:-1:-1;;;;;;909:10924:82;;;;;;;;;;;;;8085:29:33;;909:10924:82;;8085:29:33;7979:146;;;;;7894:76;-1:-1:-1;;;7936:23:33;;;;;909:10924:82;;;","linkReferences":{"src/libraries/StrategyLibrary.sol":{"StrategyLibrary":[{"start":1507,"length":20},{"start":3395,"length":20}]}}},"deployedBytecode":{"object":"0x6080806040526004361015610012575f80fd5b5f905f3560e01c9081630d8e6e2c146119d05750806329caf0bb146117655780634648f9031461164f5780634f1ef2861461144957806352d1902d146113cd5780636c451e4f14611376578063715018a61461130f5780637323d1dc1461129d578063751c4c8314610b73578063787cc3e8146109645780638da5cb5b1461092f5780639048086f146108705780639f8f3244146107ce578063a8754aa214610712578063ad3cb1cc146106c8578063b79f8a8b14610471578063c4d66de81461033a578063ce6e13ff1461028c578063d77ab72d14610263578063d88490d01461023b578063f2fde38b1461020e578063f405e5b8146101565763fe25333a1461011b575f80fd5b34610153576020366003190112610153576020906040906001600160a01b03610142611a4d565b168152600283522054604051908152f35b80fd5b503461015357604036600319011261015357610170611a4d565b600354602435916001600160a01b0391821633036101fc5716808352826020526040832082845260205260408320805415806101f0575b6101de576006429101557f07264369268ed39a83671d08cb89484ddb5660037f2e7ec2ae6917e44427fa426020604051428152a380f35b604051632df15a4160e11b8152600490fd5b506003810154156101a7565b6040516303c4eecf60e21b8152600490fd5b50346101535760203660031901126101535761023861022b611a4d565b610233611fbf565b611f4e565b80f35b5034610153576020366003190112610153576020906040906001600160a01b03610142611a4d565b50346101535780600319360112610153576003546040516001600160a01b039091168152602090f35b5034610153576020366003190112610153576102a6611a4d565b6102ae611fbf565b6001600160a01b0390811690811561030257600354826bffffffffffffffffffffffff60a01b821617600355167f24bfaf52118d10c0defabb4f43e353b9c8aa2b4eb66946b56f272a5745dfb58c8380a380f35b60405162461bcd60e51b815260206004820152601060248201526f24b73b30b634b21032bc32b1baba37b960811b6044820152606490fd5b503461015357602036600319011261015357610354611a4d565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090815460ff8160401c1615916001600160401b03821680159081610469575b600114908161045f575b159081610456575b506104445767ffffffffffffffff19821660011784556103d79183610425575b506103cf6120e8565b6102336120e8565b6103df6120e8565b6103e7575080f35b68ff00000000000000001981541690557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a180f35b68ffffffffffffffffff1916680100000000000000011784555f6103c6565b60405163f92ee8a960e01b8152600490fd5b9050155f6103a6565b303b15915061039e565b849150610394565b50346101535760803660031901126101535761048b611a4d565b602435906001600160401b036044358181116106c4576104af903690600401611c5a565b90916064358181116106c0576104c9903690600401611c5a565b9060018060a01b038096169586895260209389855260408a20898b52855260408a20805415806106b4575b6101de57600192806001830154163314158061069a575b610688578b73__$dba9e2f2db071a4fcbbef338f63ec817de$__803b1561068457818789928c8e610552604051968795869485946323a7592960e11b865260048601611e82565b03915af4801561067957610661575b5050600382019083891161064d576105798983611d9b565b89918d52878d208d925b8a841061062d5750505050600401908411610619576105a28482611d9b565b8952838920828a5b858110610608575050505091610602917f6db76c8a3889c0731b3752f6ea9abcd361cf982366fdde8d31bc729190a799369594936105f5604051968796604088526040880191611ef7565b9285840390860152611e5e565b0390a380f35b8135838201559086019083016105aa565b634e487b7160e01b8a52604160045260248afd5b8035938385168503610649578a88920194818401550192610583565b8f80fd5b634e487b7160e01b8d52604160045260248dfd5b61066a90611b91565b610675578b5f610561565b8b80fd5b6040513d84823e3d90fd5b5080fd5b60405163ea8e4eb560e01b8152600490fd5b50805f8051602061218d833981519152541633141561050b565b506003810154156104f4565b8680fd5b8480fd5b503461015357806003193601126101535761070e6040516106e881611ba4565b60058152640352e302e360dc1b6020820152604051918291602083526020830190611a0f565b0390f35b50346101535760403660031901126101535761072c611a4d565b6001600160a01b03908116808352602083815260408085206024358087529252842080549193909115806107c2575b6101de578060018301541633141590816107a7575b5061068857600701805460ff191690557f6fe898767072debe4012739f5364c570c493a82c0c58270b3724b1a1700708d38380a380f35b90505f8051602061218d83398151915254163314155f610770565b5060038201541561075b565b50346101535760403660031901126101535760406107ea611a4d565b9160018060a01b0380931681528060205281812060243582526020522061070e815491836001820154169360028201541690600581015460068201549061083b600860ff6007860154169401611cc2565b9360405197889788526020880152604087015260608601526080850152151560a084015260e060c084015260e0830190611a0f565b50346101535760403660031901126101535761088a611a4d565b6001600160a01b0390811680835260208381526040808520602435808752925284208054919390911580610923575b6101de57806001830154163314159081610908575b5061068857600701805460ff191660011790557f5bdc7734939384f886d0744037b20922c8b610626171a851c34e94001faf0ccb8380a380f35b90505f8051602061218d83398151915254163314155f6108ce565b506003820154156108b9565b50346101535780600319360112610153575f8051602061218d833981519152546040516001600160a01b039091168152602090f35b503461015357602080600319360112610684576001600160a01b0380610988611a4d565b169283815260019182845261099f60408320611e10565b8051956109c46109ae88611ee0565b976109bc604051998a611bbf565b808952611ee0565b601f1901845b818110610b575750508484905b610a3d575b5050505060405192808401908085528551809252604085018160408460051b880101970193905b838210610a105786880387f35b90919293948380610a2c839a603f198b82030186528951611a77565b999701959493919091019101610a03565b908291869896949351811015610b4e57849082875286895260408720610a638286611f3a565b51885289526040872060405190610a7982611b61565b805482528684820154168b8301528660028201541660408301526003810160405190818d82549182815201918c528d808d20918d915b818310610b3457505050509181610acd600893610b0c950382611bbf565b6060850152610ade60048201611e10565b6080850152600581015460a0850152600681015460c085015260ff600782015416151560e085015201611cc2565b610100820152610b1c828a611f3a565b52610b278189611f3a565b50019091929395976109d7565b83548d1685528d999401939283019291909101908f610aaf565b509694966109dc565b8790610b64999799611dcd565b82828a010152019795976109ca565b50346111e45760c03660031901126111e457610b8d611a4d565b6044356001600160401b0381116111e457610bac903690600401611c5a565b906064356001600160401b0381116111e457610bcc903690600401611c5a565b60a492919235916001600160401b0383116111e457366023840112156111e4576001600160401b038360040135116111e4573660248460040135850101116111e457610c1786612026565b1561128b576001600160a01b03610c2d87612072565b16948515611246578533141580611225575b6106885760018060a01b0387165f525f60205260405f206024355f5260205260405f2054158015906111fa575b6111e85773__$dba9e2f2db071a4fcbbef338f63ec817de$__803b156111e4575f60405180926323a7592960e11b82528180610cae898c898b60048601611e82565b03915af480156111d9576111c6575b506084351561118e5783600401351561115a57604051610cdc81611b61565b6024358152602081018790526001600160a01b0388166040820152610d0082611ee0565b610d0d6040519182611bbf565b82815260208101368460051b86011161113e5784905b8460051b860182106111425750506060820152610d3f84611ee0565b610d4c6040519182611bbf565b84815260208101368660051b89011161113e5787905b8660051b8901821061112e575050608082015260843560a08201524260c0820152600160e0820152610d9c36866004013560248801611bfb565b6101008201526001600160a01b038881168a5260208a81526040808c206024358d528252808c2084518155918401516001830180549185166001600160a01b0319928316179055908401516002830180549190941691161790915560608201518051919291906001600160401b0382116110fd57602090610e208360038701611d9b565b01600384018c5260208c208c5b838110611111575050505060808101518051906001600160401b0382116110fd57602090610e5e8360048701611d9b565b01600484018c5260208c208c5b8381106110e957505050508060a0610100920151600584015560c081015160068401556007830160e0820151151560ff8019835416911617905501518051906001600160401b0382116110d557610ec56008840154611c8a565b601f8111611097575b50602090601f831160011461102b57600892918c9183611020575b50508160011b915f199060031b1c1916179101555b6001600160a01b0387168852600160205260408820805490600160401b8210156106195781610f35916001610f4e94018155611c31565b6024359082549060031b91821b915f19901b1916179055565b6001600160a01b038716885260026020526040882080545f19811461100c577ff027eb8b70490a503951d126e80b22a66771a2f115457bbfa215e214b920429a959361100693608096936001610fe8940190556040519687966060885280600401356060890152806004013560248201838a01376004013587810182018e9052601f01601f19168701878103820160208901520191611ef7565b8381036040850152602435986001600160a01b031696909190611e5e565b0390a480f35b634e487b7160e01b8a52601160045260248afd5b015190505f80610ee9565b90600884018c5260208c20918c5b601f198516811061107f5750918391600193600895601f19811610611067575b505050811b01910155610efe565b01515f1960f88460031b161c191690555f8080611059565b91926020600181928685015181550194019201611039565b6110c590600885018d5260208d20601f850160051c810191602086106110cb575b601f0160051c0190611d64565b5f610ece565b90915081906110b8565b634e487b7160e01b8b52604160045260248bfd5b600190602084519401938184015501610e6b565b634e487b7160e01b8c52604160045260248cfd5b82516001600160a01b031681830155602090920191600101610e2d565b8135815260209182019101610d62565b8a80fd5b6020809161114f84611a63565b815201910190610d23565b60405162461bcd60e51b815260206004820152600c60248201526b496e76616c6964206e616d6560a01b6044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201526f125b9d985b1a59081a5b9d195c9d985b60821b6044820152606490fd5b6111d1919850611b91565b5f965f610cbd565b6040513d5f823e3d90fd5b5f80fd5b60405163c45546f760e01b8152600490fd5b5060018060a01b0387165f525f60205260405f206024355f52602052600360405f2001541515610c6c565b505f8051602061218d833981519152546001600160a01b0316331415610c3f565b60405162461bcd60e51b815260206004820152601760248201527f496e76616c69642044656c654761746f72206f776e65720000000000000000006044820152606490fd5b6040516305a18a2360e31b8152600490fd5b346111e4576020806003193601126111e4576001600160a01b036112bf611a4d565b165f52600190600181526112d560405f20611e10565b9160405191808301818452845180915281604085019501915f5b8281106112fc5785870386f35b83518752958101959281019284016112ef565b346111e4575f3660031901126111e457611327611fbf565b5f8051602061218d83398151915280546001600160a01b031981169091555f906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b346111e45760403660031901126111e45761138f611a4d565b6001600160a01b03165f908152600160205260409020805460243591908210156111e4576020916113bf91611c31565b90546040519160031b1c8152f35b346111e4575f3660031901126111e4577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036114375760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b60405163703e46dd60e11b8152600490fd5b60403660031901126111e45761145d611a4d565b6024356001600160401b0381116111e457366023820112156111e45761148d903690602481600401359101611bfb565b906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116308114908115611621575b50611437576114d1611fbf565b8116906040516352d1902d60e01b8152602081600481865afa5f91816115ed575b5061151057604051634c9c8ce360e01b815260048101849052602490fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc929192908181036115d55750823b156115bc5780546001600160a01b03191682179055604051907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156115a357505f808360206115a195519101845af461159b611ff7565b91612129565b005b915050346115ad57005b63b398979f60e01b8152600490fd5b604051634c9c8ce360e01b815260048101839052602490fd5b60249060405190632a87526960e21b82526004820152fd5b9091506020813d602011611619575b8161160960209383611bbf565b810103126111e4575190856114f2565b3d91506115fc565b9050817f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc54161415846114c4565b346111e45760403660031901126111e457611668611a4d565b611670611dcd565b5060018060a01b038091165f5260205f815260405f206024355f52815260405f206040519261169e84611b61565b815484526001908060018401541684860152806002840154166040860152600383019060405192838684549182815201935f52865f20925f905b8883831061174e578a9061173460088b8b6116f5818d0382611bbf565b606086015261170660048201611e10565b6080860152600581015460a0860152600681015460c086015260ff600782015416151560e086015201611cc2565b61010083015261070e604051928284938452830190611a77565b8554821687529095019493830193908301906116d8565b346111e45760403660031901126111e45761177e611a4d565b602480359060018060a01b0380931690815f526020905f825260405f20845f52825260405f2094855415806119c4575b6101de57806001809701541633141590816119a9575b50610688578490835f525f835260405f20855f52835260405f205f81555f838201555f600282015560086003916117fd60038201611d7a565b61180960048201611d7a565b5f60058201555f60068201555f6007820155016118268154611c8a565b908161196e575b5050909150835f5285835260405f20865f905b61189e575b50505050816002929394505f525260405f208054801561188a575f190190557f4dcd504f23c1c204f965486c526a1e35cfb215bb4823dd1be0a172277bb1b3455f80a3005b634e487b7160e01b5f52601160045260245ffd5b81548082101561196857876118b38385611c31565b905490861b1c146118c75750870187611840565b9091929397505f1991828201918211611955576118f76118ea61190f9386611c31565b905490871b1c9185611c31565b90919082549060031b91821b915f19901b1916179055565b81549687156119425750806002959697019261192b8484611c31565b81939154921b1b1916905555839291858080611845565b634e487b7160e01b5f9081526031600452fd5b88634e487b7160e01b5f5260116004525ffd5b50611845565b81601f5f93116001146119855750555b878061182d565b9080839182526119a2601f898420940160051c8401888501611d64565b555561197e565b90505f8051602061218d8339815191525416331415866117c4565b506003860154156117ae565b346111e4575f3660031901126111e457806119ed61070e92611ba4565b60058152640312e302e360dc1b60208201526040519182916020835260208301905b91908251928382525f5b848110611a39575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201611a19565b600435906001600160a01b03821682036111e457565b35906001600160a01b03821682036111e457565b919091610120908184019381518152602094858301519060018060a01b0380921687840152816040850151166040840152606084015194606084015284518091528661014084019501915f905b88838310611b4757505050505060808201519281810360808301528580855192838152019401905f5b818110611b3357505050611b3093945060a082015160a082015260c082015160c082015260e0820151151560e08201526101008092015191818403910152611a0f565b90565b825186529487019491870191600101611aed565b845182168852968701969093019260019190910190611ac4565b61012081019081106001600160401b03821117611b7d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b038111611b7d57604052565b604081019081106001600160401b03821117611b7d57604052565b90601f801991011681019081106001600160401b03821117611b7d57604052565b6001600160401b038111611b7d57601f01601f191660200190565b929192611c0782611be0565b91611c156040519384611bbf565b8294818452818301116111e4578281602093845f960137010152565b8054821015611c46575f5260205f2001905f90565b634e487b7160e01b5f52603260045260245ffd5b9181601f840112156111e4578235916001600160401b0383116111e4576020808501948460051b0101116111e457565b90600182811c92168015611cb8575b6020831014611ca457565b634e487b7160e01b5f52602260045260245ffd5b91607f1691611c99565b9060405191825f8254611cd481611c8a565b908184526020946001916001811690815f14611d425750600114611d04575b505050611d0292500383611bbf565b565b5f90815285812095935091905b818310611d2a575050611d0293508201015f8080611cf3565b85548884018501529485019487945091830191611d11565b92505050611d0294925060ff191682840152151560051b8201015f8080611cf3565b818110611d6f575050565b5f8155600101611d64565b80545f825580611d88575050565b611d02915f5260205f2090810190611d64565b90600160401b8111611b7d57815490808355818110611db957505050565b611d02925f5260205f209182019101611d64565b60405190611dda82611b61565b6060610100835f81525f60208201525f604082015282808201528260808201525f60a08201525f60c08201525f60e08201520152565b90604051918281549182825260209260208301915f5260205f20935f905b828210611e4457505050611d0292500383611bbf565b855484526001958601958895509381019390910190611e2e565b81835290916001600160fb1b0383116111e45760209260051b809284830137010190565b949391949290928560408201604083525260608101935f965b808810611eb7575050611b309495506020818503910152611e5e565b90946001906001600160a01b03611ecd88611a63565b1681526020809101960197019690611e9b565b6001600160401b038111611b7d5760051b60200190565b9190808252602080920192915f5b828110611f13575050505090565b909192938280600192838060a01b03611f2b89611a63565b16815201950193929101611f05565b8051821015611c465760209160051b010190565b6001600160a01b03908116908115611fa7575f8051602061218d83398151915280546001600160a01b031981168417909155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b604051631e4fbdf760e01b81525f6004820152602490fd5b5f8051602061218d833981519152546001600160a01b03163303611fdf57565b60405163118cdaa760e01b8152336004820152602490fd5b3d15612021573d9061200882611be0565b916120166040519384611bbf565b82523d5f602084013e565b606090565b803b1561206d575f80916040516020810190638da5cb5b60e01b82526004815261204f81611ba4565b51915afa61205b611ff7565b81612064575090565b60209150511490565b505f90565b803b1561206d575f80916040516020810190638da5cb5b60e01b82526004815261209b81611ba4565b51915afa6120a7611ff7565b90806120dd575b6120b757505f90565b6020818051810103126111e457602001516001600160a01b038116908190036111e45790565b5060208151146120ae565b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c161561211757565b604051631afcd79f60e31b8152600490fd5b90612150575080511561213e57602081519101fd5b60405163d6bda27560e01b8152600490fd5b81511580612183575b612161575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b1561215956fe9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300a26469706673582212201db3a3a3b8e97357214dfbd0d89ba13875545553021b9d10fde720fdba279c9164736f6c63430008170033","sourceMap":"909:10924:82:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;;;-1:-1:-1;;;;;909:10924:82;;:::i;:::-;;;;1333:52;909:10924;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;9582:17;909:10924;;;;-1:-1:-1;;;;;909:10924:82;;;9568:10;:31;9564:92;;909:10924;;;;;;;;;;;;;;;;;;;;9753:16;:47;;;909:10924;9749:103;;9862:26;9891:15;9862:26;;909:10924;9922:59;909:10924;;;9891:15;909:10924;;9922:59;909:10924;;9749:103;909:10924;;-1:-1:-1;;;9823:18:82;;909:10924;;9823:18;9753:47;9773:15;9582:17;9773:15;;909:10924;9773:27;9753:47;;9564:92;909:10924;;-1:-1:-1;;;9622:23:82;;909:10924;;9622:23;909:10924;;;;;;;-1:-1:-1;;909:10924:82;;;;2357:1:32;909:10924:82;;:::i;:::-;2303:62:32;;:::i;:::-;2357:1;:::i;:::-;909:10924:82;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;;;-1:-1:-1;;;;;909:10924:82;;:::i;:::-;;;;;;;;;;;;;1472:32;909:10924;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;2303:62:32;;:::i;:::-;-1:-1:-1;;;;;909:10924:82;;;;3092:23;;909:10924;;3168:17;909:10924;;;;;;;;3168:17;909:10924;;3239:48;;;;909:10924;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;3147:66:33;909:10924:82;;;;;;;;4301:16:33;909:10924:82;-1:-1:-1;;;;;909:10924:82;;4724:16:33;;:34;;;;909:10924:82;4803:1:33;4788:16;:50;;;;909:10924:82;4853:13:33;:30;;;;909:10924:82;4849:91:33;;;-1:-1:-1;;909:10924:82;;4803:1:33;909:10924:82;;;6959:1:33;;909:10924:82;4977:67:33;;909:10924:82;6891:76:33;;;:::i;:::-;;;:::i;6959:1::-;6891:76;;:::i;:::-;5064:101;;909:10924:82;;;5064:101:33;909:10924:82;;;;;;;5140:14:33;909:10924:82;;;4803:1:33;909:10924:82;;5140:14:33;909:10924:82;;4977:67:33;-1:-1:-1;;909:10924:82;;;;;4977:67:33;;;4849:91;909:10924:82;;-1:-1:-1;;;4906:23:33;;909:10924:82;;4906:23:33;4853:30;4870:13;;;4853:30;;;4788:50;4816:4;4808:25;:30;;-1:-1:-1;4788:50:33;;4724:34;;;-1:-1:-1;4724:34:33;;909:10924:82;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6307:16;:47;;;909:10924;6303:103;;909:10924;6489:14;;909:10924;6489:14;;909:10924;;6475:10;:28;;:53;;;909:10924;6471:106;;6622:15;;:49;;;;;909:10924;;;;;;6622:49;909:10924;;;;;;;;;;;;6622:49;;909:10924;6622:49;;;:::i;:::-;;;;;;;;;;;909:10924;6709:15;;;;;909:10924;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;6743:16;;;;909:10924;6743:16;909:10924;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;6785:55;909:10924;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;6785:55;;;909:10924;;;;;;;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;6622:49;;;;:::i;:::-;909:10924;;6622:49;;;;909:10924;;;;6622:49;909:10924;;;;;;;;;6622:49;909:10924;;;6471:106;909:10924;;-1:-1:-1;;;6551:15:82;;909:10924;;6551:15;6475:53;909:10924;;-1:-1:-1;;;;;;;;;;;909:10924:82;;6475:10;6507:21;;6475:53;;6307:47;6327:15;;;;909:10924;6327:27;6307:47;;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;7182:16;;:47;;909:10924;7178:103;;7364:14;909:10924;7364:14;;909:10924;;7350:10;:28;;:53;;;;909:10924;7346:106;;;7462:17;;909:10924;;-1:-1:-1;;909:10924:82;;;7503:37;;;;909:10924;;7350:53;909:10924;;-1:-1:-1;;;;;;;;;;;909:10924:82;;7350:10;7382:21;;7350:53;;;7182:47;7202:15;;;;909:10924;7202:27;7182:47;;909:10924;;;;;;;-1:-1:-1;;909:10924:82;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;1100:82;;909:10924;1100:82;;909:10924;;1100:82;;;;909:10924;;1100:82;;;;909:10924;1100:82;;;909:10924;1100:82;;;909:10924;1100:82;;;909:10924;;1100:82;;;:::i;:::-;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;7872:16;;:47;;909:10924;7868:103;;8054:14;909:10924;8054:14;;909:10924;;8040:10;:28;;:53;;;;909:10924;8036:106;;;8152:17;;909:10924;;-1:-1:-1;;909:10924:82;;;;;8192:38;;;;909:10924;;8040:53;909:10924;;-1:-1:-1;;;;;;;;;;;909:10924:82;;8040:10;8072:21;;8040:53;;;7872:47;7892:15;;;;909:10924;7892:27;7872:47;;909:10924;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;909:10924:82;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;:::i;:::-;;;;;;11152:15;909:10924;;;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;;:::i;:::-;-1:-1:-1;;909:10924:82;;;;;;;;11292:13;;;;11287:110;11152:15;;;11287:110;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;11323:3;909:10924;;;;;;;;;11307:14;;;;;909:10924;;;;;;;;;;;11379:6;;;;:::i;:::-;909:10924;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;11342:44;;;;:::i;:::-;;;;;;:::i;:::-;;909:10924;11292:13;;;;;;;;909:10924;;;;;;;;;;;;;;;;;;;;;;;;11307:14;;;;;;;909:10924;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;4256:38;;;:::i;:::-;4255:39;4251:92;;-1:-1:-1;;;;;4424:44:82;;;:::i;:::-;909:10924;4486:28;;;909:10924;;4643:10;;:28;;:53;;;909:10924;4639:106;;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;4807:41;;;:96;;;909:10924;4803:157;;5001:15;:49;;;;;909:10924;;;;;;;;5001:49;;;;;;;;;909:10924;5001:49;;;:::i;:::-;;;;;;;;;;;909:10924;;;;5068:21;909:10924;;;;;;5128:22;909:10924;;;;;;;:::i;:::-;;;;;;5241:341;;909:10924;;;-1:-1:-1;;;;;909:10924:82;;;5241:341;;909:10924;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;5241:341;;909:10924;5241:341;;909:10924;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;5241:341;;909:10924;5241:341;;909:10924;;;;5241:341;;909:10924;5504:15;909:10924;5241:341;;909:10924;;;5241:341;;909:10924;;;;;;;;;;;:::i;:::-;5241:341;;;909:10924;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;5241:341;;;909:10924;;;;;;;;;-1:-1:-1;;;;;;909:10924:82;;;;;;5241:341;;;909:10924;;;;;;;;;;;;;;;;;5241:341;;909:10924;;;;;5241:341;909:10924;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;5241:341;;;;909:10924;5241:341;;909:10924;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;5241:341;;;;;909:10924;5241:341;;;909:10924;;;;;;5241:341;;909:10924;;;;;;;;;5241:341;;909:10924;;;;;;;;;;;;;;5241:341;909:10924;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;5721:77;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;:::i;:::-;5721:77;;;909:10924;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;909:10924:82;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;-1:-1:-1;;;909:10924:82;;;;;;;5001:49;;;;;;:::i;:::-;909:10924;5001:49;;;;;909:10924;;;;;;;;;5001:49;909:10924;;;4803:157;909:10924;;-1:-1:-1;;;4926:23:82;;909:10924;;4926:23;4807:96;909:10924;;;;;;;;;;;;;;;;;;;;;;4852:40;909:10924;;;4852:40;909:10924;4852:51;;4807:96;;4643:53;-1:-1:-1;;;;;;;;;;;;909:10924:82;-1:-1:-1;;;;;909:10924:82;4643:10;4675:21;;4643:53;;909:10924;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;;;;4251:92;909:10924;;-1:-1:-1;;;4317:15:82;;909:10924;;4317:15;909:10924;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;:::i;:::-;;;;10585:15;909:10924;10585:15;909:10924;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;2303:62:32;;:::i;:::-;-1:-1:-1;;;;;;;;;;;909:10924:82;;-1:-1:-1;;;;;;909:10924:82;;;;;;;-1:-1:-1;;;;;909:10924:82;3975:40:32;909:10924:82;;3975:40:32;909:10924:82;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;1235:52;;;;;909:10924;1235:52;;;;:::i;:::-;909:10924;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;5090:6:34;-1:-1:-1;;;;;909:10924:82;5081:4:34;5073:23;5069:145;;909:10924:82;;;811:66:48;909:10924:82;;;5069:145:34;909:10924:82;;-1:-1:-1;;;5174:29:34;;909:10924:82;;5174:29:34;909:10924:82;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;-1:-1:-1;;;;;4667:6:34;909:10924:82;;4658:4:34;4650:23;;;:120;;;;909:10924:82;4633:251:34;;;2303:62:32;;:::i;:::-;909:10924:82;;;;;;;;6131:52:34;;909:10924:82;6131:52:34;909:10924:82;6131:52:34;;;;909:10924:82;;6131:52:34;;;909:10924:82;-1:-1:-1;6127:437:34;;909:10924:82;;-1:-1:-1;;;6493:60:34;;909:10924:82;6493:60:34;;909:10924:82;;;;;6493:60:34;6127:437;811:66:48;;;;6225:40:34;;;;6221:120;;1748:29:48;;;:34;1744:119;;909:10924:82;;-1:-1:-1;;;;;;909:10924:82;;;;;;;;2407:36:48;-1:-1:-1;;2407:36:48;909:10924:82;;2458:15:48;:11;;4065:25:55;909:10924:82;4065:25:55;;909:10924:82;4107:55:55;4065:25;;;;;;;;;:::i;:::-;4107:55;;:::i;:::-;909:10924:82;2454:148:48;6163:9;;;;6159:70;;909:10924:82;6159:70:48;-1:-1:-1;;;6199:19:48;;909:10924:82;;6199:19:48;1744:119;909:10924:82;;-1:-1:-1;;;1805:47:48;;909:10924:82;1805:47:48;;909:10924:82;;;;;1805:47:48;6221:120:34;909:10924:82;;;;6292:34:34;;;;;;909:10924:82;6292:34:34;;909:10924:82;6292:34:34;6131:52;;;;909:10924:82;6131:52:34;;909:10924:82;6131:52:34;;;;;;909:10924:82;6131:52:34;;;:::i;:::-;;;909:10924:82;;;;;6131:52:34;;;;;;;-1:-1:-1;6131:52:34;;4650:120;909:10924:82;;;811:66:48;909:10924:82;;4728:42:34;;4650:120;;;909:10924:82;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8555:16;:47;;;909:10924;8551:103;;909:10924;;8737:14;;;909:10924;;8723:10;:28;;:53;;;;909:10924;8719:106;;;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;9010:13;909:10924;9005:202;909:10924;;;9005:202;909:10924;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;909:10924:82;;;9263:38;909:10924;;9263:38;909:10924;;;;;;;;;;;;;9041:3;909:10924;;9025:14;;;;;;9064:6;;;;;:::i;:::-;909:10924;;;;;;9064:20;9060:137;;-1:-1:-1;909:10924:82;;9041:3;9010:13;;9060:137;909:10924;;;;;;;;;;;;;;;;;9104:6;9113:19;9104:28;9113:19;;;:::i;:::-;909:10924;;;;;;9104:6;;;:::i;:::-;:28;909:10924;;;;;;;;;;;;;;;;;;;;;9104:28;909:10924;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;9177:5;;;;;;;;909:10924;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;;;;9025:14;;;;909:10924;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;8723:53;909:10924;;-1:-1:-1;;;;;;;;;;;909:10924:82;;8723:10;8755:21;;8723:53;;;8555:47;8575:15;;;;909:10924;8575:27;8555:47;;909:10924;;;;;;-1:-1:-1;;909:10924:82;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;:::o;:::-;;;-1:-1:-1;;;;;909:10924:82;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;:::o;:::-;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;:::o;:::-;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;:::o;:::-;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;:::o;:::-;-1:-1:-1;;;;;909:10924:82;;;;;;-1:-1:-1;;909:10924:82;;;;:::o;:::-;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;;;:::o;:::-;;;;;;;;-1:-1:-1;909:10924:82;;-1:-1:-1;909:10924:82;;;-1:-1:-1;909:10924:82;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:::o;:::-;-1:-1:-1;909:10924:82;;;;;;;;-1:-1:-1;;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;:::i;:::-;;-1:-1:-1;;;909:10924:82;;;;;;;;;;;;;;;;;;:::o;:::-;;;-1:-1:-1;909:10924:82;;-1:-1:-1;909:10924:82;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;-1:-1:-1;909:10924:82;;-1:-1:-1;909:10924:82;;;;-1:-1:-1;909:10924:82;;;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;-1:-1:-1;909:10924:82;;;;-1:-1:-1;909:10924:82;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;-1:-1:-1;909:10924:82;;-1:-1:-1;909:10924:82;;-1:-1:-1;909:10924:82;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;-1:-1:-1;;;;;909:10924:82;;;:::i;:::-;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;909:10924:82;;;;;;;;;:::o;:::-;;;;;;;;;;;;-1:-1:-1;909:10924:82;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;3405:215:32:-;-1:-1:-1;;;;;909:10924:82;;;;3489:22:32;;3485:91;;-1:-1:-1;;;;;;;;;;;909:10924:82;;-1:-1:-1;;;;;;909:10924:82;;;;;;;;3975:40:32;-1:-1:-1;;3975:40:32;3405:215::o;3485:91::-;909:10924:82;;-1:-1:-1;;;3534:31:32;;3509:1;3534:31;;;909:10924:82;;;3534:31:32;2658:162;-1:-1:-1;;;;;;;;;;;909:10924:82;-1:-1:-1;;;;;909:10924:82;966:10:35;2717:23:32;2713:101;;2658:162::o;2713:101::-;909:10924:82;;-1:-1:-1;;;2763:40:32;;966:10:35;2763:40:32;;;909:10924:82;;;2763:40:32;909:10924:82;;;;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;-1:-1:-1;909:10924:82;;;;:::o;:::-;;;:::o;1386:660:87:-;920:61;;997:8;1518:68;;-1:-1:-1;909:10924:82;;;;1807:34:87;;;;;;;;;;;;;;;:::i;:::-;1775:76;;;;;;:::i;:::-;2011:28;;;2004:35;1386:660;:::o;2011:28::-;1807:34;909:10924:82;;;2022:17:87;1386:660;:::o;1518:68::-;1563:12;-1:-1:-1;1563:12:87;:::o;2414:519::-;920:61;;997:8;2556:75;;-1:-1:-1;909:10924:82;;;;2751:34:87;;;1807;;;;2751;;;;;;;;:::i;:::-;2717:78;;;;;;:::i;:::-;2810:28;;;;2414:519;2806:93;;2909:17;-1:-1:-1;2414:519:87;:::o;2806:93::-;2751:34;909:10924:82;;;2861:27:87;;909:10924:82;;;;2751:34:87;2861:27;909:10924:82;-1:-1:-1;;;;;909:10924:82;;;;;;;;2854:34:87;:::o;2810:28::-;909:10924:82;2751:34:87;909:10924:82;;2821:17:87;2810:28;;7082:141:33;909:10924:82;3147:66:33;909:10924:82;;;;7148:18:33;7144:73;;7082:141::o;7144:73::-;909:10924:82;;-1:-1:-1;;;7189:17:33;;;;;4437:582:55;;4609:8;;-1:-1:-1;909:10924:82;;5690:21:55;:17;;5815:105;;;;;;5686:301;909:10924:82;;-1:-1:-1;;;5957:19:55;;;;;4605:408;909:10924:82;;4857:22:55;:49;;;4605:408;4853:119;;4985:17;;:::o;4853:119::-;909:10924:82;;-1:-1:-1;;;4933:24:55;;-1:-1:-1;;;;;909:10924:82;;;4933:24:55;;;909:10924:82;;;4933:24:55;4857:49;4883:18;;;:23;4857:49;","linkReferences":{"src/libraries/StrategyLibrary.sol":{"StrategyLibrary":[{"start":1298,"length":20},{"start":3186,"length":20}]}},"immutableReferences":{"42267":[{"start":5087,"length":32},{"start":5272,"length":32}]}},"methodIdentifiers":{"UPGRADE_INTERFACE_VERSION()":"ad3cb1cc","createStrategy(address,uint256,address[],uint256[],uint256,string)":"751c4c83","deleteStrategy(address,uint256)":"29caf0bb","getAllUserStrategies(address)":"787cc3e8","getStrategy(address,uint256)":"4648f903","getUserStrategyCount(address)":"d88490d0","getUserStrategyIds(address)":"7323d1dc","getVersion()":"0d8e6e2c","initialize(address)":"c4d66de8","owner()":"8da5cb5b","pauseStrategy(address,uint256)":"a8754aa2","proxiableUUID()":"52d1902d","rebalanceExecutor()":"d77ab72d","renounceOwnership()":"715018a6","resumeStrategy(address,uint256)":"9048086f","setRebalanceExecutor(address)":"ce6e13ff","strategies(address,uint256)":"9f8f3244","transferOwnership(address)":"f2fde38b","updateLastRebalanceTime(address,uint256)":"f405e5b8","updateStrategy(address,uint256,address[],uint256[])":"b79f8a8b","upgradeToAndCall(address,bytes)":"4f1ef286","userStrategyCount(address)":"fe25333a","userStrategyIds(address,uint256)":"6c451e4f"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ERC1967InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967NonPayable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStrategyId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotADeleGator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRebalanceExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStrategyOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LastRebalanceTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"RebalanceExecutorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"name\":\"StrategyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"StrategyDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"StrategyPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"StrategyResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"name\":\"StrategyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UPGRADE_INTERFACE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rebalanceInterval\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"createStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"deleteStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllUserStrategies\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rebalanceInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRebalanceTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct StrategyLibrary.Strategy[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"getStrategy\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rebalanceInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRebalanceTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct StrategyLibrary.Strategy\",\"name\":\"strategy\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStrategyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStrategyIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"pauseStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"resumeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"setRebalanceExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rebalanceInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRebalanceTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"updateLastRebalanceTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"name\":\"updateStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStrategyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStrategyIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"SMART ACCOUNT ONLY: All strategies must use MetaMask DeleGator accounts Architecture: - ONE shared registry for ALL DeleGators - Each DeleGator can have MULTIPLE strategies - Data isolated by mapping: DeleGator address => strategy ID => strategy - No custody: funds stay in DeleGator smart accounts - Owner verification: EOA that owns the DeleGator must approve strategy creation\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"ERC1967InvalidImplementation(address)\":[{\"details\":\"The `implementation` of the proxy is invalid.\"}],\"ERC1967NonPayable()\":[{\"details\":\"An upgrade function sees `msg.value > 0` that may be lost.\"}],\"FailedCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"UUPSUnauthorizedCallContext()\":[{\"details\":\"The call is from an unauthorized context.\"}],\"UUPSUnsupportedProxiableUUID(bytes32)\":[{\"details\":\"The storage `slot` is unsupported as a UUID.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"Upgraded(address)\":{\"details\":\"Emitted when the implementation is upgraded.\"}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"createStrategy(address,uint256,address[],uint256[],uint256,string)\":{\"details\":\"SMART ACCOUNT ONLY: delegator must be a MetaMask DeleGator      Authorization: Either the DeleGator owner (EOA) or contract owner (backend) can create\",\"params\":{\"delegator\":\"DeleGator smart account address (must be a MetaMask DeleGator)\",\"name\":\"Human-readable name\",\"rebalanceInterval\":\"Minimum seconds between rebalances\",\"strategyId\":\"Unique ID for this strategy (user-defined)\",\"tokens\":\"Token addresses in strategy\",\"weights\":\"Token weights in basis points (must sum to 10000)\"}},\"deleteStrategy(address,uint256)\":{\"params\":{\"delegator\":\"DeleGator address\",\"strategyId\":\"Strategy ID to delete\"}},\"getAllUserStrategies(address)\":{\"params\":{\"user\":\"User address\"},\"returns\":{\"_0\":\"Array of strategies\"}},\"getStrategy(address,uint256)\":{\"params\":{\"strategyId\":\"Strategy ID\",\"user\":\"User address\"},\"returns\":{\"strategy\":\"Strategy data\"}},\"getUserStrategyCount(address)\":{\"params\":{\"user\":\"User address\"},\"returns\":{\"count\":\"Number of strategies\"}},\"getUserStrategyIds(address)\":{\"params\":{\"user\":\"User address\"},\"returns\":{\"_0\":\"Strategy IDs\"}},\"getVersion()\":{\"returns\":{\"_0\":\"Version string\"}},\"initialize(address)\":{\"params\":{\"_owner\":\"Owner address\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pauseStrategy(address,uint256)\":{\"params\":{\"delegator\":\"DeleGator address\",\"strategyId\":\"Strategy ID to pause\"}},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"resumeStrategy(address,uint256)\":{\"params\":{\"delegator\":\"DeleGator address\",\"strategyId\":\"Strategy ID to resume\"}},\"setRebalanceExecutor(address)\":{\"params\":{\"_executor\":\"RebalanceExecutor contract address\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateLastRebalanceTime(address,uint256)\":{\"params\":{\"strategyId\":\"Strategy ID\",\"user\":\"User address\"}},\"updateStrategy(address,uint256,address[],uint256[])\":{\"params\":{\"delegator\":\"DeleGator address\",\"strategyId\":\"Strategy ID to update\",\"tokens\":\"New token addresses\",\"weights\":\"New token weights\"}},\"upgradeToAndCall(address,bytes)\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"title\":\"StrategyRegistry\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createStrategy(address,uint256,address[],uint256[],uint256,string)\":{\"notice\":\"Create a new strategy for a DeleGator smart account\"},\"deleteStrategy(address,uint256)\":{\"notice\":\"Delete a strategy\"},\"getAllUserStrategies(address)\":{\"notice\":\"Get all strategies for a user\"},\"getStrategy(address,uint256)\":{\"notice\":\"Get a specific strategy\"},\"getUserStrategyCount(address)\":{\"notice\":\"Get strategy count for a user\"},\"getUserStrategyIds(address)\":{\"notice\":\"Get all strategy IDs for a user\"},\"getVersion()\":{\"notice\":\"Get contract version\"},\"initialize(address)\":{\"notice\":\"Initialize the registry\"},\"pauseStrategy(address,uint256)\":{\"notice\":\"Pause a strategy (stops rebalancing)\"},\"rebalanceExecutor()\":{\"notice\":\"Address allowed to update lastRebalanceTime (RebalanceExecutor)\"},\"resumeStrategy(address,uint256)\":{\"notice\":\"Resume a paused strategy\"},\"setRebalanceExecutor(address)\":{\"notice\":\"Set rebalance executor address (only owner)\"},\"strategies(address,uint256)\":{\"notice\":\"User => Strategy ID => Strategy\"},\"updateLastRebalanceTime(address,uint256)\":{\"notice\":\"Update last rebalance time (only callable by RebalanceExecutor)\"},\"updateStrategy(address,uint256,address[],uint256[])\":{\"notice\":\"Update an existing strategy\"},\"userStrategyCount(address)\":{\"notice\":\"User => Strategy count\"},\"userStrategyIds(address,uint256)\":{\"notice\":\"User => Array of strategy IDs\"}},\"notice\":\"Shared registry for all DeleGator smart account strategies (non-custodial)\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/StrategyRegistry.sol\":\"StrategyRegistry\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@FCL/=lib/delegation-framework/lib/FCL/solidity/src/\",\":@SCL/=lib/delegation-framework/lib/SCL/src/\",\":@account-abstraction/=lib/delegation-framework/lib/account-abstraction/contracts/\",\":@bytes-utils/=lib/delegation-framework/lib/solidity-bytes-utils/contracts/\",\":@delegation-framework/=lib/delegation-framework/src/\",\":@erc7579/=lib/erc7579-implementation/src/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@pythnetwork/pyth-sdk-solidity/=lib/pyth-sdk-solidity/\",\":@solidity-stringutils/=lib/delegation-framework/lib/solidity-stringutils/src/\",\":@solidity/=lib/delegation-framework/lib/SCL/src/\",\":FCL/=lib/delegation-framework/lib/FCL/solidity/src/\",\":FreshCryptoLib/=lib/delegation-framework/lib/FreshCryptoLib/solidity/src/\",\":SCL/=lib/delegation-framework/lib/SCL/\",\":account-abstraction/=lib/account-abstraction/contracts/\",\":delegation-framework/=lib/delegation-framework/\",\":ds-test/=lib/erc7579-implementation/node_modules/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\":erc7579-implementation/=lib/erc7579-implementation/src/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":pyth-sdk-solidity/=lib/pyth-sdk-solidity/\",\":sentinellist/=lib/erc7579-implementation/node_modules/@rhinestone/sentinellist/src/\",\":solady/=lib/erc7579-implementation/node_modules/solady/src/\",\":solidity-bytes-utils/=lib/delegation-framework/lib/solidity-bytes-utils/contracts/\",\":solidity-stringutils/=lib/delegation-framework/lib/solidity-stringutils/\"],\"viaIR\":true},\"sources\":{\"lib/delegation-framework/lib/account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"lib/delegation-framework/src/utils/Types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT AND Apache-2.0\\npragma solidity 0.8.23;\\n\\nimport { PackedUserOperation } from \\\"@account-abstraction/interfaces/PackedUserOperation.sol\\\";\\nimport { Execution } from \\\"@erc7579/interfaces/IERC7579Account.sol\\\";\\nimport { ModeCode, CallType, ExecType, ModeSelector, ModePayload } from \\\"@erc7579/lib/ModeLib.sol\\\";\\n\\n/**\\n * @title EIP712Domain\\n * @notice Struct representing the EIP712 domain for signature validation.\\n */\\nstruct EIP712Domain {\\n    string name;\\n    string version;\\n    uint256 chainId;\\n    address verifyingContract;\\n}\\n\\n/**\\n * @title Delegation\\n * @notice Struct representing a delegation to give a delegate authority to act on behalf of a delegator.\\n * @dev `signature` is ignored during delegation hashing so it can be manipulated post signing.\\n */\\nstruct Delegation {\\n    address delegate;\\n    address delegator;\\n    bytes32 authority;\\n    Caveat[] caveats;\\n    uint256 salt;\\n    bytes signature;\\n}\\n\\n/**\\n * @title Caveat\\n * @notice Struct representing a caveat to enforce on a delegation.\\n * @dev `args` is ignored during caveat hashing so it can be manipulated post signing.\\n */\\nstruct Caveat {\\n    address enforcer;\\n    bytes terms;\\n    bytes args;\\n}\\n\\n/**\\n * @title P256 Public Key\\n * @notice Struct containing the X and Y coordinates of a P256 public key.\\n */\\nstruct P256PublicKey {\\n    uint256 x;\\n    uint256 y;\\n}\\n\\nstruct DecodedWebAuthnSignature {\\n    uint256 r;\\n    uint256 s;\\n    bytes authenticatorData;\\n    bool requireUserVerification;\\n    string clientDataJSONPrefix;\\n    string clientDataJSONSuffix;\\n    uint256 responseTypeLocation;\\n}\\n\",\"keccak256\":\"0xda4094eb4839087157f34750fb4d1a2d6241fbb8ee0d41fd1f2905209e6a05b0\",\"license\":\"MIT AND Apache-2.0\"},\"lib/erc7579-implementation/src/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579Account {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x08368aba5f1bb83eb57e9f8d31a04edee4be69159b4844a6443f65100917011c\",\"license\":\"MIT\"},\"lib/erc7579-implementation/src/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0x02ce0fc8805d1427841f32e2335157e3fae18e99d5c49ba46d53e12fcd1a5185\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\\n    struct OwnableStorage {\\n        address _owner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\\n\\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\\n        assembly {\\n            $.slot := OwnableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        return $._owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        address oldOwner = $._owner;\\n        $._owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xc163fcf9bb10138631a9ba5564df1fa25db9adff73bd9ee868a8ae1858fe093a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.22;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC-1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x574a7451e42724f7de29e2855c392a8a5020acd695169466a18459467d719d63\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\\n\\npragma solidity >=0.4.11;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0xbf2aefe54b76d7f7bcd4f6da1080b7b1662611937d870b880db584d09cea56b5\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x82f757819bf2429a0d4db141b99a4bbe5039e4ef86dfb94e2e6d40577ed5b28b\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.21;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {IERC1967} from \\\"../../interfaces/IERC1967.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This library provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit IERC1967.Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit IERC1967.BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1ad192cd45317c788618bef5cb1fb3ca4ce8b230f6433ac68cc1d850fb81618\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x20462ddb2665e9521372c76b001d0ce196e59dbbd989de9af5576cad0bd5628b\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0x74ed01eb66b923d0d0cfe3be84604ac04b76482a55f9dd655e1ef4d367f95bc2\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xd6fa4088198f04eef10c5bce8a2f4d60554b7ec4b987f684393c01bf79b94d9f\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6d0ae6e206645341fd122d278c2cb643dea260c190531f2f3f6a0426e77b00c0\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"src/StrategyRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./libraries/StrategyLibrary.sol\\\";\\nimport \\\"./delegation/types/DelegationTypes.sol\\\";\\n\\n/**\\n * @title StrategyRegistry\\n * @notice Shared registry for all DeleGator smart account strategies (non-custodial)\\n * @dev SMART ACCOUNT ONLY: All strategies must use MetaMask DeleGator accounts\\n *\\n * Architecture:\\n * - ONE shared registry for ALL DeleGators\\n * - Each DeleGator can have MULTIPLE strategies\\n * - Data isolated by mapping: DeleGator address => strategy ID => strategy\\n * - No custody: funds stay in DeleGator smart accounts\\n * - Owner verification: EOA that owns the DeleGator must approve strategy creation\\n */\\ncontract StrategyRegistry is Initializable, UUPSUpgradeable, OwnableUpgradeable {\\n    using StrategyLibrary for StrategyLibrary.Strategy;\\n\\n    /// @notice User => Strategy ID => Strategy\\n    mapping(address => mapping(uint256 => StrategyLibrary.Strategy)) public strategies;\\n\\n    /// @notice User => Array of strategy IDs\\n    mapping(address => uint256[]) public userStrategyIds;\\n\\n    /// @notice User => Strategy count\\n    mapping(address => uint256) public userStrategyCount;\\n\\n    /// @notice Address allowed to update lastRebalanceTime (RebalanceExecutor)\\n    address public rebalanceExecutor;\\n\\n    // Events\\n    event StrategyCreated(\\n        address indexed delegator,\\n        address indexed owner,\\n        uint256 indexed strategyId,\\n        string name,\\n        address[] tokens,\\n        uint256[] weights\\n    );\\n    event StrategyUpdated(address indexed delegator, uint256 indexed strategyId, address[] tokens, uint256[] weights);\\n    event StrategyPaused(address indexed delegator, uint256 indexed strategyId);\\n    event StrategyResumed(address indexed delegator, uint256 indexed strategyId);\\n    event StrategyDeleted(address indexed delegator, uint256 indexed strategyId);\\n    event RebalanceExecutorUpdated(address indexed oldExecutor, address indexed newExecutor);\\n    event LastRebalanceTimeUpdated(address indexed delegator, uint256 indexed strategyId, uint256 timestamp);\\n\\n    // Errors\\n    error StrategyAlreadyExists();\\n    error StrategyNotFound();\\n    error InvalidStrategyId();\\n    error OnlyStrategyOwner();\\n    error OnlyRebalanceExecutor();\\n    error NotADeleGator();\\n    error NotAuthorized();\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initialize the registry\\n     * @param _owner Owner address\\n     */\\n    function initialize(address _owner) external initializer {\\n        __Ownable_init(_owner);\\n        __UUPSUpgradeable_init();\\n    }\\n\\n    /**\\n     * @notice Set rebalance executor address (only owner)\\n     * @param _executor RebalanceExecutor contract address\\n     */\\n    function setRebalanceExecutor(address _executor) external onlyOwner {\\n        require(_executor != address(0), \\\"Invalid executor\\\");\\n        address oldExecutor = rebalanceExecutor;\\n        rebalanceExecutor = _executor;\\n        emit RebalanceExecutorUpdated(oldExecutor, _executor);\\n    }\\n\\n    /**\\n     * @notice Create a new strategy for a DeleGator smart account\\n     * @param delegator DeleGator smart account address (must be a MetaMask DeleGator)\\n     * @param strategyId Unique ID for this strategy (user-defined)\\n     * @param tokens Token addresses in strategy\\n     * @param weights Token weights in basis points (must sum to 10000)\\n     * @param rebalanceInterval Minimum seconds between rebalances\\n     * @param name Human-readable name\\n     *\\n     * @dev SMART ACCOUNT ONLY: delegator must be a MetaMask DeleGator\\n     *      Authorization: Either the DeleGator owner (EOA) or contract owner (backend) can create\\n     */\\n    function createStrategy(\\n        address delegator,\\n        uint256 strategyId,\\n        address[] calldata tokens,\\n        uint256[] calldata weights,\\n        uint256 rebalanceInterval,\\n        string calldata name\\n    ) external {\\n        // CRITICAL: Validate delegator is a DeleGator smart account\\n        if (!DelegationTypes.isDeleGator(delegator)) {\\n            revert NotADeleGator();\\n        }\\n\\n        // Get the EOA owner of the DeleGator\\n        address delegatorOwner = DelegationTypes.getDeleGatorOwner(delegator);\\n        require(delegatorOwner != address(0), \\\"Invalid DeleGator owner\\\");\\n\\n        // Authorization: Either the owner EOA or contract owner (backend) can create\\n        if (msg.sender != delegatorOwner && msg.sender != owner()) {\\n            revert NotAuthorized();\\n        }\\n\\n        // Check strategy doesn't already exist\\n        if (strategies[delegator][strategyId].id != 0 || strategies[delegator][strategyId].tokens.length > 0) {\\n            revert StrategyAlreadyExists();\\n        }\\n\\n        // Validate parameters\\n        StrategyLibrary.validateStrategy(tokens, weights);\\n        require(rebalanceInterval > 0, \\\"Invalid interval\\\");\\n        require(bytes(name).length > 0, \\\"Invalid name\\\");\\n\\n        // Create strategy\\n        strategies[delegator][strategyId] = StrategyLibrary.Strategy({\\n            id: strategyId,\\n            owner: delegatorOwner,\\n            delegator: delegator,\\n            tokens: tokens,\\n            weights: weights,\\n            rebalanceInterval: rebalanceInterval,\\n            lastRebalanceTime: block.timestamp,\\n            isActive: true,\\n            name: name\\n        });\\n\\n        // Track strategy ID\\n        userStrategyIds[delegator].push(strategyId);\\n        userStrategyCount[delegator]++;\\n\\n        emit StrategyCreated(delegator, delegatorOwner, strategyId, name, tokens, weights);\\n    }\\n\\n    /**\\n     * @notice Update an existing strategy\\n     * @param delegator DeleGator address\\n     * @param strategyId Strategy ID to update\\n     * @param tokens New token addresses\\n     * @param weights New token weights\\n     */\\n    function updateStrategy(\\n        address delegator,\\n        uint256 strategyId,\\n        address[] calldata tokens,\\n        uint256[] calldata weights\\n    ) external {\\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\\n\\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\\n            revert StrategyNotFound();\\n        }\\n\\n        // Authorization: Only owner or contract owner\\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\\n            revert NotAuthorized();\\n        }\\n\\n        // Validate new parameters\\n        StrategyLibrary.validateStrategy(tokens, weights);\\n\\n        // Update strategy\\n        strategy.tokens = tokens;\\n        strategy.weights = weights;\\n\\n        emit StrategyUpdated(delegator, strategyId, tokens, weights);\\n    }\\n\\n    /**\\n     * @notice Pause a strategy (stops rebalancing)\\n     * @param delegator DeleGator address\\n     * @param strategyId Strategy ID to pause\\n     */\\n    function pauseStrategy(address delegator, uint256 strategyId) external {\\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\\n\\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\\n            revert StrategyNotFound();\\n        }\\n\\n        // Authorization: Only owner or contract owner\\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\\n            revert NotAuthorized();\\n        }\\n\\n        strategy.isActive = false;\\n\\n        emit StrategyPaused(delegator, strategyId);\\n    }\\n\\n    /**\\n     * @notice Resume a paused strategy\\n     * @param delegator DeleGator address\\n     * @param strategyId Strategy ID to resume\\n     */\\n    function resumeStrategy(address delegator, uint256 strategyId) external {\\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\\n\\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\\n            revert StrategyNotFound();\\n        }\\n\\n        // Authorization: Only owner or contract owner\\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\\n            revert NotAuthorized();\\n        }\\n\\n        strategy.isActive = true;\\n\\n        emit StrategyResumed(delegator, strategyId);\\n    }\\n\\n    /**\\n     * @notice Delete a strategy\\n     * @param delegator DeleGator address\\n     * @param strategyId Strategy ID to delete\\n     */\\n    function deleteStrategy(address delegator, uint256 strategyId) external {\\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\\n\\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\\n            revert StrategyNotFound();\\n        }\\n\\n        // Authorization: Only owner or contract owner\\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\\n            revert NotAuthorized();\\n        }\\n\\n        // Delete strategy\\n        delete strategies[delegator][strategyId];\\n\\n        // Remove from ID array\\n        uint256[] storage ids = userStrategyIds[delegator];\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            if (ids[i] == strategyId) {\\n                ids[i] = ids[ids.length - 1];\\n                ids.pop();\\n                break;\\n            }\\n        }\\n\\n        userStrategyCount[delegator]--;\\n\\n        emit StrategyDeleted(delegator, strategyId);\\n    }\\n\\n    /**\\n     * @notice Update last rebalance time (only callable by RebalanceExecutor)\\n     * @param user User address\\n     * @param strategyId Strategy ID\\n     */\\n    function updateLastRebalanceTime(address user, uint256 strategyId) external {\\n        if (msg.sender != rebalanceExecutor) {\\n            revert OnlyRebalanceExecutor();\\n        }\\n\\n        StrategyLibrary.Strategy storage strategy = strategies[user][strategyId];\\n\\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\\n            revert StrategyNotFound();\\n        }\\n\\n        strategy.lastRebalanceTime = block.timestamp;\\n\\n        emit LastRebalanceTimeUpdated(user, strategyId, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Get a specific strategy\\n     * @param user User address\\n     * @param strategyId Strategy ID\\n     * @return strategy Strategy data\\n     */\\n    function getStrategy(address user, uint256 strategyId)\\n        external\\n        view\\n        returns (StrategyLibrary.Strategy memory strategy)\\n    {\\n        return strategies[user][strategyId];\\n    }\\n\\n    /**\\n     * @notice Get all strategy IDs for a user\\n     * @param user User address\\n     * @return Strategy IDs\\n     */\\n    function getUserStrategyIds(address user) external view returns (uint256[] memory) {\\n        return userStrategyIds[user];\\n    }\\n\\n    /**\\n     * @notice Get strategy count for a user\\n     * @param user User address\\n     * @return count Number of strategies\\n     */\\n    function getUserStrategyCount(address user) external view returns (uint256 count) {\\n        return userStrategyCount[user];\\n    }\\n\\n    /**\\n     * @notice Get all strategies for a user\\n     * @param user User address\\n     * @return Array of strategies\\n     */\\n    function getAllUserStrategies(address user) external view returns (StrategyLibrary.Strategy[] memory) {\\n        uint256[] memory ids = userStrategyIds[user];\\n        StrategyLibrary.Strategy[] memory userStrategies = new StrategyLibrary.Strategy[](ids.length);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            userStrategies[i] = strategies[user][ids[i]];\\n        }\\n\\n        return userStrategies;\\n    }\\n\\n    /**\\n     * @notice Authorize upgrade (UUPS requirement)\\n     * @param newImplementation New implementation address\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\\n\\n    /**\\n     * @notice Get contract version\\n     * @return Version string\\n     */\\n    function getVersion() external pure returns (string memory) {\\n        return \\\"1.0.0\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x1d94beba833d71895050b588b218348b0dab471c17bce02a3c9dd69d8256c575\",\"license\":\"MIT\"},\"src/delegation/types/DelegationTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n// Use MetaMask's official types from Delegation Framework\\nimport { Delegation, Caveat } from \\\"@delegation-framework/utils/Types.sol\\\";\\n\\n/**\\n * @title DelegationTypes\\n * @notice Utility library for working with MetaMask DeleGator smart accounts\\n * @dev Provides helper functions for DeleGator detection and ownership verification\\n *\\n * This library uses MetaMask's official Delegation Framework types and does not\\n * implement custom delegation logic. All delegation validation and execution\\n * is handled by the DelegationManager contract.\\n */\\nlibrary DelegationTypes {\\n    /**\\n     * @notice Check if address has contract code deployed\\n     * @param account Address to check\\n     * @return hasCode True if address has code (is a contract)\\n     */\\n    function isSmartContract(address account) internal view returns (bool hasCode) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @notice Check if address is a MetaMask DeleGator smart account\\n     * @param account Address to check\\n     * @return isDeleGatorAccount True if account is a DeleGator\\n     *\\n     * @dev Attempts to call owner() function which is present on HybridDeleGator\\n     *      and other DeleGator implementations. If the call succeeds, it's a DeleGator.\\n     */\\n    function isDeleGator(address account) internal view returns (bool isDeleGatorAccount) {\\n        // Must be a smart contract\\n        if (!isSmartContract(account)) {\\n            return false;\\n        }\\n\\n        // Try to call owner() function (present on HybridDeleGator)\\n        // Using low-level call to avoid revert if function doesn't exist\\n        (bool success, bytes memory data) = account.staticcall(\\n            abi.encodeWithSignature(\\\"owner()\\\")\\n        );\\n\\n        // If call succeeded and returned data, it's likely a DeleGator\\n        // HybridDeleGator.owner() returns address, which is 32 bytes\\n        return success && data.length == 32;\\n    }\\n\\n    /**\\n     * @notice Get the EOA owner of a DeleGator smart account\\n     * @param delegator DeleGator smart account address\\n     * @return owner EOA address that owns and controls the DeleGator\\n     *\\n     * @dev HybridDeleGator has an owner() function that returns the EOA owner\\n     *      Returns address(0) if not a DeleGator or owner() call fails\\n     */\\n    function getDeleGatorOwner(address delegator) internal view returns (address owner) {\\n        // Validate it's a smart contract first\\n        if (!isSmartContract(delegator)) {\\n            return address(0);\\n        }\\n\\n        // Try to call owner() function\\n        (bool success, bytes memory data) = delegator.staticcall(\\n            abi.encodeWithSignature(\\\"owner()\\\")\\n        );\\n\\n        if (success && data.length == 32) {\\n            return abi.decode(data, (address));\\n        }\\n\\n        return address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x15a28c4f81f13119012e3e0690b601b4e1df24b956b40e44900cdfab475bf152\",\"license\":\"MIT\"},\"src/interfaces/IPythOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/**\\n * @title IPythOracle\\n * @notice Interface for PythOracle wrapper contract\\n */\\ninterface IPythOracle {\\n    // Events\\n    event PriceFeedSet(address indexed token, bytes32 indexed feedId);\\n    event PriceFeedRemoved(address indexed token);\\n    event MaxPriceAgeUpdated(uint256 oldValue, uint256 newValue);\\n    event MaxConfidenceRatioUpdated(uint256 oldValue, uint256 newValue);\\n\\n    // Errors\\n    error NoFeedConfigured(address token);\\n    error InvalidPrice(address token, int64 price);\\n    error ConfidenceTooLow(uint64 conf, uint64 price, uint256 ratio);\\n\\n    // Configuration\\n    function setPriceFeed(address token, bytes32 feedId) external;\\n    function removePriceFeed(address token) external;\\n    function setMaxPriceAge(uint256 seconds_) external;\\n    function setMaxConfidenceRatio(uint256 bps) external;\\n\\n    // Price queries\\n    function getPrice(address token) external view returns (uint256 price);\\n    function batchGetPrices(address[] calldata tokens) external view returns (uint256[] memory prices);\\n    function isPriceFresh(address token) external view returns (bool);\\n\\n    // Getters\\n    function getVersion() external pure returns (string memory);\\n    function getPythContract() external view returns (address);\\n    function oracle() external view returns (address);\\n    function pythContract() external view returns (address);\\n    function priceFeeds(address) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x4059b66bdd20b817bcc047c2cb6723d2fc56d3eb5152325411b79847d36b14c0\",\"license\":\"MIT\"},\"src/libraries/StrategyLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"../interfaces/IPythOracle.sol\\\";\\n\\n/**\\n * @title StrategyLibrary\\n * @notice Pure calculation logic for portfolio strategies (no state)\\n * @dev Used by RebalanceExecutor to calculate rebalance swaps\\n *\\n * Non-custodial: All calculations based on user's MetaMask account balances\\n */\\nlibrary StrategyLibrary {\\n    struct Strategy {\\n        uint256 id;\\n        address owner;        // EOA that owns the DeleGator smart account\\n        address delegator;    // DeleGator smart account address (holds funds)\\n        address[] tokens;\\n        uint256[] weights;  // Basis points (100 = 1%)\\n        uint256 rebalanceInterval;\\n        uint256 lastRebalanceTime;\\n        bool isActive;\\n        string name;\\n    }\\n\\n    error InvalidWeights();\\n    error InvalidTokenCount();\\n    error ZeroAddress();\\n\\n    /**\\n     * @notice Calculate required swaps to rebalance portfolio\\n     * @param account DeleGator smart account address (holds funds)\\n     * @param strategy Strategy configuration\\n     * @param oracle Price oracle address\\n     * @return tokensToSell Tokens that need to be sold\\n     * @return tokensToBuy Tokens that need to be bought\\n     * @return amountsToSell Amounts to sell for each token\\n     */\\n    function calculateRebalanceSwaps(\\n        address account,\\n        Strategy memory strategy,\\n        address oracle\\n    )\\n        external\\n        view\\n        returns (address[] memory tokensToSell, address[] memory tokensToBuy, uint256[] memory amountsToSell)\\n    {\\n        require(account != address(0), \\\"Invalid account\\\");\\n        require(oracle != address(0), \\\"Invalid oracle\\\");\\n\\n        // Get current balances from user's account\\n        uint256[] memory balances = new uint256[](strategy.tokens.length);\\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\\n            balances[i] = IERC20(strategy.tokens[i]).balanceOf(account);\\n        }\\n\\n        // Get current prices\\n        uint256[] memory prices = IPythOracle(oracle).batchGetPrices(strategy.tokens);\\n\\n        // Calculate total portfolio value\\n        uint256 totalValueUSD = 0;\\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\\n            // Adjust for token decimals\\n            uint8 decimals = IERC20Metadata(strategy.tokens[i]).decimals();\\n            uint256 valueUSD = (balances[i] * prices[i]) / (10 ** decimals);\\n            totalValueUSD += valueUSD;\\n        }\\n\\n        // Calculate target values for each token\\n        uint256[] memory targetValuesUSD = new uint256[](strategy.tokens.length);\\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\\n            targetValuesUSD[i] = (totalValueUSD * strategy.weights[i]) / 10000;\\n        }\\n\\n        // Calculate current values for each token\\n        uint256[] memory currentValuesUSD = new uint256[](strategy.tokens.length);\\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\\n            uint8 decimals = IERC20Metadata(strategy.tokens[i]).decimals();\\n            currentValuesUSD[i] = (balances[i] * prices[i]) / (10 ** decimals);\\n        }\\n\\n        // Determine which tokens to sell and buy\\n        uint256 sellCount = 0;\\n        uint256 buyCount = 0;\\n\\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\\n            if (currentValuesUSD[i] > targetValuesUSD[i]) {\\n                sellCount++;\\n            } else if (currentValuesUSD[i] < targetValuesUSD[i]) {\\n                buyCount++;\\n            }\\n        }\\n\\n        tokensToSell = new address[](sellCount);\\n        tokensToBuy = new address[](buyCount);\\n        amountsToSell = new uint256[](sellCount);\\n\\n        uint256 sellIndex = 0;\\n        uint256 buyIndex = 0;\\n\\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\\n            if (currentValuesUSD[i] > targetValuesUSD[i]) {\\n                tokensToSell[sellIndex] = strategy.tokens[i];\\n\\n                // Calculate amount to sell (in token units)\\n                uint256 excessValueUSD = currentValuesUSD[i] - targetValuesUSD[i];\\n                uint8 decimals = IERC20Metadata(strategy.tokens[i]).decimals();\\n                amountsToSell[sellIndex] = (excessValueUSD * (10 ** decimals)) / prices[i];\\n\\n                sellIndex++;\\n            } else if (currentValuesUSD[i] < targetValuesUSD[i]) {\\n                tokensToBuy[buyIndex] = strategy.tokens[i];\\n                buyIndex++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate current allocation weights\\n     * @param account DeleGator smart account address (holds funds)\\n     * @param tokens Token addresses\\n     * @param oracle Price oracle address\\n     * @return weights Current weights in basis points\\n     */\\n    function calculateCurrentWeights(address account, address[] memory tokens, address oracle)\\n        external\\n        view\\n        returns (uint256[] memory weights)\\n    {\\n        require(account != address(0), \\\"Invalid account\\\");\\n        require(oracle != address(0), \\\"Invalid oracle\\\");\\n\\n        uint256[] memory balances = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            balances[i] = IERC20(tokens[i]).balanceOf(account);\\n        }\\n\\n        uint256[] memory prices = IPythOracle(oracle).batchGetPrices(tokens);\\n\\n        uint256 totalValueUSD = 0;\\n        uint256[] memory valuesUSD = new uint256[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint8 decimals = IERC20Metadata(tokens[i]).decimals();\\n            valuesUSD[i] = (balances[i] * prices[i]) / (10 ** decimals);\\n            totalValueUSD += valuesUSD[i];\\n        }\\n\\n        weights = new uint256[](tokens.length);\\n        if (totalValueUSD == 0) {\\n            return weights; // All zeros if no balance\\n        }\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            weights[i] = (valuesUSD[i] * 10000) / totalValueUSD;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate drift between current and target weights\\n     * @param currentWeights Current allocation in basis points\\n     * @param targetWeights Target allocation in basis points\\n     * @return drift Maximum deviation in basis points\\n     */\\n    function calculateDrift(uint256[] memory currentWeights, uint256[] memory targetWeights)\\n        external\\n        pure\\n        returns (uint256 drift)\\n    {\\n        require(currentWeights.length == targetWeights.length, \\\"Length mismatch\\\");\\n\\n        drift = 0;\\n        for (uint256 i = 0; i < currentWeights.length; i++) {\\n            uint256 deviation = currentWeights[i] > targetWeights[i]\\n                ? currentWeights[i] - targetWeights[i]\\n                : targetWeights[i] - currentWeights[i];\\n\\n            if (deviation > drift) {\\n                drift = deviation;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get total portfolio value in USD\\n     * @param account DeleGator smart account address (holds funds)\\n     * @param tokens Token addresses\\n     * @param oracle Price oracle address\\n     * @return totalValueUSD Portfolio value scaled to 18 decimals\\n     */\\n    function getPortfolioValue(address account, address[] memory tokens, address oracle)\\n        external\\n        view\\n        returns (uint256 totalValueUSD)\\n    {\\n        require(account != address(0), \\\"Invalid account\\\");\\n        require(oracle != address(0), \\\"Invalid oracle\\\");\\n\\n        uint256[] memory balances = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            balances[i] = IERC20(tokens[i]).balanceOf(account);\\n        }\\n\\n        uint256[] memory prices = IPythOracle(oracle).batchGetPrices(tokens);\\n\\n        totalValueUSD = 0;\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint8 decimals = IERC20Metadata(tokens[i]).decimals();\\n            uint256 valueUSD = (balances[i] * prices[i]) / (10 ** decimals);\\n            totalValueUSD += valueUSD;\\n        }\\n    }\\n\\n    /**\\n     * @notice Validate strategy parameters\\n     * @param tokens Token addresses\\n     * @param weights Token weights in basis points\\n     */\\n    function validateStrategy(address[] memory tokens, uint256[] memory weights) external pure {\\n        if (tokens.length == 0 || tokens.length > 10) {\\n            revert InvalidTokenCount();\\n        }\\n\\n        if (tokens.length != weights.length) {\\n            revert InvalidTokenCount();\\n        }\\n\\n        // Check no zero addresses\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            if (tokens[i] == address(0)) {\\n                revert ZeroAddress();\\n            }\\n        }\\n\\n        // Check weights sum to 10000 (100%)\\n        uint256 totalWeight = 0;\\n        for (uint256 i = 0; i < weights.length; i++) {\\n            totalWeight += weights[i];\\n        }\\n\\n        if (totalWeight != 10000) {\\n            revert InvalidWeights();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbc35a0ae821b47e89d941c2e201722988bb3b992d3f034706838f6de194340f9\",\"license\":\"MIT\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.23+commit.f704f362"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"type":"error","name":"AddressEmptyCode"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"type":"error","name":"ERC1967InvalidImplementation"},{"inputs":[],"type":"error","name":"ERC1967NonPayable"},{"inputs":[],"type":"error","name":"FailedCall"},{"inputs":[],"type":"error","name":"InvalidInitialization"},{"inputs":[],"type":"error","name":"InvalidStrategyId"},{"inputs":[],"type":"error","name":"NotADeleGator"},{"inputs":[],"type":"error","name":"NotAuthorized"},{"inputs":[],"type":"error","name":"NotInitializing"},{"inputs":[],"type":"error","name":"OnlyRebalanceExecutor"},{"inputs":[],"type":"error","name":"OnlyStrategyOwner"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"type":"error","name":"OwnableInvalidOwner"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"type":"error","name":"OwnableUnauthorizedAccount"},{"inputs":[],"type":"error","name":"StrategyAlreadyExists"},{"inputs":[],"type":"error","name":"StrategyNotFound"},{"inputs":[],"type":"error","name":"UUPSUnauthorizedCallContext"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"type":"error","name":"UUPSUnsupportedProxiableUUID"},{"inputs":[{"internalType":"uint64","name":"version","type":"uint64","indexed":false}],"type":"event","name":"Initialized","anonymous":false},{"inputs":[{"internalType":"address","name":"delegator","type":"address","indexed":true},{"internalType":"uint256","name":"strategyId","type":"uint256","indexed":true},{"internalType":"uint256","name":"timestamp","type":"uint256","indexed":false}],"type":"event","name":"LastRebalanceTimeUpdated","anonymous":false},{"inputs":[{"internalType":"address","name":"previousOwner","type":"address","indexed":true},{"internalType":"address","name":"newOwner","type":"address","indexed":true}],"type":"event","name":"OwnershipTransferred","anonymous":false},{"inputs":[{"internalType":"address","name":"oldExecutor","type":"address","indexed":true},{"internalType":"address","name":"newExecutor","type":"address","indexed":true}],"type":"event","name":"RebalanceExecutorUpdated","anonymous":false},{"inputs":[{"internalType":"address","name":"delegator","type":"address","indexed":true},{"internalType":"address","name":"owner","type":"address","indexed":true},{"internalType":"uint256","name":"strategyId","type":"uint256","indexed":true},{"internalType":"string","name":"name","type":"string","indexed":false},{"internalType":"address[]","name":"tokens","type":"address[]","indexed":false},{"internalType":"uint256[]","name":"weights","type":"uint256[]","indexed":false}],"type":"event","name":"StrategyCreated","anonymous":false},{"inputs":[{"internalType":"address","name":"delegator","type":"address","indexed":true},{"internalType":"uint256","name":"strategyId","type":"uint256","indexed":true}],"type":"event","name":"StrategyDeleted","anonymous":false},{"inputs":[{"internalType":"address","name":"delegator","type":"address","indexed":true},{"internalType":"uint256","name":"strategyId","type":"uint256","indexed":true}],"type":"event","name":"StrategyPaused","anonymous":false},{"inputs":[{"internalType":"address","name":"delegator","type":"address","indexed":true},{"internalType":"uint256","name":"strategyId","type":"uint256","indexed":true}],"type":"event","name":"StrategyResumed","anonymous":false},{"inputs":[{"internalType":"address","name":"delegator","type":"address","indexed":true},{"internalType":"uint256","name":"strategyId","type":"uint256","indexed":true},{"internalType":"address[]","name":"tokens","type":"address[]","indexed":false},{"internalType":"uint256[]","name":"weights","type":"uint256[]","indexed":false}],"type":"event","name":"StrategyUpdated","anonymous":false},{"inputs":[{"internalType":"address","name":"implementation","type":"address","indexed":true}],"type":"event","name":"Upgraded","anonymous":false},{"inputs":[],"stateMutability":"view","type":"function","name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}]},{"inputs":[{"internalType":"address","name":"delegator","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"},{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"weights","type":"uint256[]"},{"internalType":"uint256","name":"rebalanceInterval","type":"uint256"},{"internalType":"string","name":"name","type":"string"}],"stateMutability":"nonpayable","type":"function","name":"createStrategy"},{"inputs":[{"internalType":"address","name":"delegator","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"deleteStrategy"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"stateMutability":"view","type":"function","name":"getAllUserStrategies","outputs":[{"internalType":"struct StrategyLibrary.Strategy[]","name":"","type":"tuple[]","components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"delegator","type":"address"},{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"weights","type":"uint256[]"},{"internalType":"uint256","name":"rebalanceInterval","type":"uint256"},{"internalType":"uint256","name":"lastRebalanceTime","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"string","name":"name","type":"string"}]}]},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"}],"stateMutability":"view","type":"function","name":"getStrategy","outputs":[{"internalType":"struct StrategyLibrary.Strategy","name":"strategy","type":"tuple","components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"delegator","type":"address"},{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"weights","type":"uint256[]"},{"internalType":"uint256","name":"rebalanceInterval","type":"uint256"},{"internalType":"uint256","name":"lastRebalanceTime","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"string","name":"name","type":"string"}]}]},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"stateMutability":"view","type":"function","name":"getUserStrategyCount","outputs":[{"internalType":"uint256","name":"count","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"stateMutability":"view","type":"function","name":"getUserStrategyIds","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}]},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"initialize"},{"inputs":[],"stateMutability":"view","type":"function","name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"address","name":"delegator","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"pauseStrategy"},{"inputs":[],"stateMutability":"view","type":"function","name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"rebalanceExecutor","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"renounceOwnership"},{"inputs":[{"internalType":"address","name":"delegator","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"resumeStrategy"},{"inputs":[{"internalType":"address","name":"_executor","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setRebalanceExecutor"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","name":"strategies","outputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"delegator","type":"address"},{"internalType":"uint256","name":"rebalanceInterval","type":"uint256"},{"internalType":"uint256","name":"lastRebalanceTime","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"string","name":"name","type":"string"}]},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"transferOwnership"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"updateLastRebalanceTime"},{"inputs":[{"internalType":"address","name":"delegator","type":"address"},{"internalType":"uint256","name":"strategyId","type":"uint256"},{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"weights","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function","name":"updateStrategy"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"payable","type":"function","name":"upgradeToAndCall"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","name":"userStrategyCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","name":"userStrategyIds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]}],"devdoc":{"kind":"dev","methods":{"constructor":{"custom:oz-upgrades-unsafe-allow":"constructor"},"createStrategy(address,uint256,address[],uint256[],uint256,string)":{"details":"SMART ACCOUNT ONLY: delegator must be a MetaMask DeleGator      Authorization: Either the DeleGator owner (EOA) or contract owner (backend) can create","params":{"delegator":"DeleGator smart account address (must be a MetaMask DeleGator)","name":"Human-readable name","rebalanceInterval":"Minimum seconds between rebalances","strategyId":"Unique ID for this strategy (user-defined)","tokens":"Token addresses in strategy","weights":"Token weights in basis points (must sum to 10000)"}},"deleteStrategy(address,uint256)":{"params":{"delegator":"DeleGator address","strategyId":"Strategy ID to delete"}},"getAllUserStrategies(address)":{"params":{"user":"User address"},"returns":{"_0":"Array of strategies"}},"getStrategy(address,uint256)":{"params":{"strategyId":"Strategy ID","user":"User address"},"returns":{"strategy":"Strategy data"}},"getUserStrategyCount(address)":{"params":{"user":"User address"},"returns":{"count":"Number of strategies"}},"getUserStrategyIds(address)":{"params":{"user":"User address"},"returns":{"_0":"Strategy IDs"}},"getVersion()":{"returns":{"_0":"Version string"}},"initialize(address)":{"params":{"_owner":"Owner address"}},"owner()":{"details":"Returns the address of the current owner."},"pauseStrategy(address,uint256)":{"params":{"delegator":"DeleGator address","strategyId":"Strategy ID to pause"}},"proxiableUUID()":{"details":"Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"resumeStrategy(address,uint256)":{"params":{"delegator":"DeleGator address","strategyId":"Strategy ID to resume"}},"setRebalanceExecutor(address)":{"params":{"_executor":"RebalanceExecutor contract address"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateLastRebalanceTime(address,uint256)":{"params":{"strategyId":"Strategy ID","user":"User address"}},"updateStrategy(address,uint256,address[],uint256[])":{"params":{"delegator":"DeleGator address","strategyId":"Strategy ID to update","tokens":"New token addresses","weights":"New token weights"}},"upgradeToAndCall(address,bytes)":{"custom:oz-upgrades-unsafe-allow-reachable":"delegatecall","details":"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}},"version":1},"userdoc":{"kind":"user","methods":{"createStrategy(address,uint256,address[],uint256[],uint256,string)":{"notice":"Create a new strategy for a DeleGator smart account"},"deleteStrategy(address,uint256)":{"notice":"Delete a strategy"},"getAllUserStrategies(address)":{"notice":"Get all strategies for a user"},"getStrategy(address,uint256)":{"notice":"Get a specific strategy"},"getUserStrategyCount(address)":{"notice":"Get strategy count for a user"},"getUserStrategyIds(address)":{"notice":"Get all strategy IDs for a user"},"getVersion()":{"notice":"Get contract version"},"initialize(address)":{"notice":"Initialize the registry"},"pauseStrategy(address,uint256)":{"notice":"Pause a strategy (stops rebalancing)"},"rebalanceExecutor()":{"notice":"Address allowed to update lastRebalanceTime (RebalanceExecutor)"},"resumeStrategy(address,uint256)":{"notice":"Resume a paused strategy"},"setRebalanceExecutor(address)":{"notice":"Set rebalance executor address (only owner)"},"strategies(address,uint256)":{"notice":"User => Strategy ID => Strategy"},"updateLastRebalanceTime(address,uint256)":{"notice":"Update last rebalance time (only callable by RebalanceExecutor)"},"updateStrategy(address,uint256,address[],uint256[])":{"notice":"Update an existing strategy"},"userStrategyCount(address)":{"notice":"User => Strategy count"},"userStrategyIds(address,uint256)":{"notice":"User => Array of strategy IDs"}},"version":1}},"settings":{"remappings":["@FCL/=lib/delegation-framework/lib/FCL/solidity/src/","@SCL/=lib/delegation-framework/lib/SCL/src/","@account-abstraction/=lib/delegation-framework/lib/account-abstraction/contracts/","@bytes-utils/=lib/delegation-framework/lib/solidity-bytes-utils/contracts/","@delegation-framework/=lib/delegation-framework/src/","@erc7579/=lib/erc7579-implementation/src/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@pythnetwork/pyth-sdk-solidity/=lib/pyth-sdk-solidity/","@solidity-stringutils/=lib/delegation-framework/lib/solidity-stringutils/src/","@solidity/=lib/delegation-framework/lib/SCL/src/","FCL/=lib/delegation-framework/lib/FCL/solidity/src/","FreshCryptoLib/=lib/delegation-framework/lib/FreshCryptoLib/solidity/src/","SCL/=lib/delegation-framework/lib/SCL/","account-abstraction/=lib/account-abstraction/contracts/","delegation-framework/=lib/delegation-framework/","ds-test/=lib/erc7579-implementation/node_modules/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","erc7579-implementation/=lib/erc7579-implementation/src/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","pyth-sdk-solidity/=lib/pyth-sdk-solidity/","sentinellist/=lib/erc7579-implementation/node_modules/@rhinestone/sentinellist/src/","solady/=lib/erc7579-implementation/node_modules/solady/src/","solidity-bytes-utils/=lib/delegation-framework/lib/solidity-bytes-utils/contracts/","solidity-stringutils/=lib/delegation-framework/lib/solidity-stringutils/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"src/StrategyRegistry.sol":"StrategyRegistry"},"evmVersion":"shanghai","libraries":{},"viaIR":true},"sources":{"lib/delegation-framework/lib/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"keccak256":"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359","urls":[],"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n","license":"GPL-3.0"},"lib/delegation-framework/src/utils/Types.sol":{"keccak256":"0xda4094eb4839087157f34750fb4d1a2d6241fbb8ee0d41fd1f2905209e6a05b0","urls":[],"content":"// SPDX-License-Identifier: MIT AND Apache-2.0\npragma solidity 0.8.23;\n\nimport { PackedUserOperation } from \"@account-abstraction/interfaces/PackedUserOperation.sol\";\nimport { Execution } from \"@erc7579/interfaces/IERC7579Account.sol\";\nimport { ModeCode, CallType, ExecType, ModeSelector, ModePayload } from \"@erc7579/lib/ModeLib.sol\";\n\n/**\n * @title EIP712Domain\n * @notice Struct representing the EIP712 domain for signature validation.\n */\nstruct EIP712Domain {\n    string name;\n    string version;\n    uint256 chainId;\n    address verifyingContract;\n}\n\n/**\n * @title Delegation\n * @notice Struct representing a delegation to give a delegate authority to act on behalf of a delegator.\n * @dev `signature` is ignored during delegation hashing so it can be manipulated post signing.\n */\nstruct Delegation {\n    address delegate;\n    address delegator;\n    bytes32 authority;\n    Caveat[] caveats;\n    uint256 salt;\n    bytes signature;\n}\n\n/**\n * @title Caveat\n * @notice Struct representing a caveat to enforce on a delegation.\n * @dev `args` is ignored during caveat hashing so it can be manipulated post signing.\n */\nstruct Caveat {\n    address enforcer;\n    bytes terms;\n    bytes args;\n}\n\n/**\n * @title P256 Public Key\n * @notice Struct containing the X and Y coordinates of a P256 public key.\n */\nstruct P256PublicKey {\n    uint256 x;\n    uint256 y;\n}\n\nstruct DecodedWebAuthnSignature {\n    uint256 r;\n    uint256 s;\n    bytes authenticatorData;\n    bool requireUserVerification;\n    string clientDataJSONPrefix;\n    string clientDataJSONSuffix;\n    uint256 responseTypeLocation;\n}\n","license":"MIT AND Apache-2.0"},"lib/erc7579-implementation/src/interfaces/IERC7579Account.sol":{"keccak256":"0x08368aba5f1bb83eb57e9f8d31a04edee4be69159b4844a6443f65100917011c","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n","license":"MIT"},"lib/erc7579-implementation/src/lib/ModeLib.sol":{"keccak256":"0x02ce0fc8805d1427841f32e2335157e3fae18e99d5c49ba46d53e12fcd1a5185","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n","license":"MIT"},"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol":{"keccak256":"0xc163fcf9bb10138631a9ba5564df1fa25db9adff73bd9ee868a8ae1858fe093a","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"keccak256":"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol":{"keccak256":"0x574a7451e42724f7de29e2855c392a8a5020acd695169466a18459467d719d63","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.22;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC-1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol":{"keccak256":"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol":{"keccak256":"0xbf2aefe54b76d7f7bcd4f6da1080b7b1662611937d870b880db584d09cea56b5","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity >=0.4.11;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol":{"keccak256":"0x82f757819bf2429a0d4db141b99a4bbe5039e4ef86dfb94e2e6d40577ed5b28b","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol":{"keccak256":"0xa1ad192cd45317c788618bef5cb1fb3ca4ce8b230f6433ac68cc1d850fb81618","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.21;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol":{"keccak256":"0x20462ddb2665e9521372c76b001d0ce196e59dbbd989de9af5576cad0bd5628b","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0x74ed01eb66b923d0d0cfe3be84604ac04b76482a55f9dd655e1ef4d367f95bc2","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0xd6fa4088198f04eef10c5bce8a2f4d60554b7ec4b987f684393c01bf79b94d9f","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"keccak256":"0x6d0ae6e206645341fd122d278c2cb643dea260c190531f2f3f6a0426e77b00c0","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/Errors.sol":{"keccak256":"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol":{"keccak256":"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n","license":"MIT"},"src/StrategyRegistry.sol":{"keccak256":"0x1d94beba833d71895050b588b218348b0dab471c17bce02a3c9dd69d8256c575","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./libraries/StrategyLibrary.sol\";\nimport \"./delegation/types/DelegationTypes.sol\";\n\n/**\n * @title StrategyRegistry\n * @notice Shared registry for all DeleGator smart account strategies (non-custodial)\n * @dev SMART ACCOUNT ONLY: All strategies must use MetaMask DeleGator accounts\n *\n * Architecture:\n * - ONE shared registry for ALL DeleGators\n * - Each DeleGator can have MULTIPLE strategies\n * - Data isolated by mapping: DeleGator address => strategy ID => strategy\n * - No custody: funds stay in DeleGator smart accounts\n * - Owner verification: EOA that owns the DeleGator must approve strategy creation\n */\ncontract StrategyRegistry is Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    using StrategyLibrary for StrategyLibrary.Strategy;\n\n    /// @notice User => Strategy ID => Strategy\n    mapping(address => mapping(uint256 => StrategyLibrary.Strategy)) public strategies;\n\n    /// @notice User => Array of strategy IDs\n    mapping(address => uint256[]) public userStrategyIds;\n\n    /// @notice User => Strategy count\n    mapping(address => uint256) public userStrategyCount;\n\n    /// @notice Address allowed to update lastRebalanceTime (RebalanceExecutor)\n    address public rebalanceExecutor;\n\n    // Events\n    event StrategyCreated(\n        address indexed delegator,\n        address indexed owner,\n        uint256 indexed strategyId,\n        string name,\n        address[] tokens,\n        uint256[] weights\n    );\n    event StrategyUpdated(address indexed delegator, uint256 indexed strategyId, address[] tokens, uint256[] weights);\n    event StrategyPaused(address indexed delegator, uint256 indexed strategyId);\n    event StrategyResumed(address indexed delegator, uint256 indexed strategyId);\n    event StrategyDeleted(address indexed delegator, uint256 indexed strategyId);\n    event RebalanceExecutorUpdated(address indexed oldExecutor, address indexed newExecutor);\n    event LastRebalanceTimeUpdated(address indexed delegator, uint256 indexed strategyId, uint256 timestamp);\n\n    // Errors\n    error StrategyAlreadyExists();\n    error StrategyNotFound();\n    error InvalidStrategyId();\n    error OnlyStrategyOwner();\n    error OnlyRebalanceExecutor();\n    error NotADeleGator();\n    error NotAuthorized();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the registry\n     * @param _owner Owner address\n     */\n    function initialize(address _owner) external initializer {\n        __Ownable_init(_owner);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @notice Set rebalance executor address (only owner)\n     * @param _executor RebalanceExecutor contract address\n     */\n    function setRebalanceExecutor(address _executor) external onlyOwner {\n        require(_executor != address(0), \"Invalid executor\");\n        address oldExecutor = rebalanceExecutor;\n        rebalanceExecutor = _executor;\n        emit RebalanceExecutorUpdated(oldExecutor, _executor);\n    }\n\n    /**\n     * @notice Create a new strategy for a DeleGator smart account\n     * @param delegator DeleGator smart account address (must be a MetaMask DeleGator)\n     * @param strategyId Unique ID for this strategy (user-defined)\n     * @param tokens Token addresses in strategy\n     * @param weights Token weights in basis points (must sum to 10000)\n     * @param rebalanceInterval Minimum seconds between rebalances\n     * @param name Human-readable name\n     *\n     * @dev SMART ACCOUNT ONLY: delegator must be a MetaMask DeleGator\n     *      Authorization: Either the DeleGator owner (EOA) or contract owner (backend) can create\n     */\n    function createStrategy(\n        address delegator,\n        uint256 strategyId,\n        address[] calldata tokens,\n        uint256[] calldata weights,\n        uint256 rebalanceInterval,\n        string calldata name\n    ) external {\n        // CRITICAL: Validate delegator is a DeleGator smart account\n        if (!DelegationTypes.isDeleGator(delegator)) {\n            revert NotADeleGator();\n        }\n\n        // Get the EOA owner of the DeleGator\n        address delegatorOwner = DelegationTypes.getDeleGatorOwner(delegator);\n        require(delegatorOwner != address(0), \"Invalid DeleGator owner\");\n\n        // Authorization: Either the owner EOA or contract owner (backend) can create\n        if (msg.sender != delegatorOwner && msg.sender != owner()) {\n            revert NotAuthorized();\n        }\n\n        // Check strategy doesn't already exist\n        if (strategies[delegator][strategyId].id != 0 || strategies[delegator][strategyId].tokens.length > 0) {\n            revert StrategyAlreadyExists();\n        }\n\n        // Validate parameters\n        StrategyLibrary.validateStrategy(tokens, weights);\n        require(rebalanceInterval > 0, \"Invalid interval\");\n        require(bytes(name).length > 0, \"Invalid name\");\n\n        // Create strategy\n        strategies[delegator][strategyId] = StrategyLibrary.Strategy({\n            id: strategyId,\n            owner: delegatorOwner,\n            delegator: delegator,\n            tokens: tokens,\n            weights: weights,\n            rebalanceInterval: rebalanceInterval,\n            lastRebalanceTime: block.timestamp,\n            isActive: true,\n            name: name\n        });\n\n        // Track strategy ID\n        userStrategyIds[delegator].push(strategyId);\n        userStrategyCount[delegator]++;\n\n        emit StrategyCreated(delegator, delegatorOwner, strategyId, name, tokens, weights);\n    }\n\n    /**\n     * @notice Update an existing strategy\n     * @param delegator DeleGator address\n     * @param strategyId Strategy ID to update\n     * @param tokens New token addresses\n     * @param weights New token weights\n     */\n    function updateStrategy(\n        address delegator,\n        uint256 strategyId,\n        address[] calldata tokens,\n        uint256[] calldata weights\n    ) external {\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\n\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\n            revert StrategyNotFound();\n        }\n\n        // Authorization: Only owner or contract owner\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\n            revert NotAuthorized();\n        }\n\n        // Validate new parameters\n        StrategyLibrary.validateStrategy(tokens, weights);\n\n        // Update strategy\n        strategy.tokens = tokens;\n        strategy.weights = weights;\n\n        emit StrategyUpdated(delegator, strategyId, tokens, weights);\n    }\n\n    /**\n     * @notice Pause a strategy (stops rebalancing)\n     * @param delegator DeleGator address\n     * @param strategyId Strategy ID to pause\n     */\n    function pauseStrategy(address delegator, uint256 strategyId) external {\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\n\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\n            revert StrategyNotFound();\n        }\n\n        // Authorization: Only owner or contract owner\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\n            revert NotAuthorized();\n        }\n\n        strategy.isActive = false;\n\n        emit StrategyPaused(delegator, strategyId);\n    }\n\n    /**\n     * @notice Resume a paused strategy\n     * @param delegator DeleGator address\n     * @param strategyId Strategy ID to resume\n     */\n    function resumeStrategy(address delegator, uint256 strategyId) external {\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\n\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\n            revert StrategyNotFound();\n        }\n\n        // Authorization: Only owner or contract owner\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\n            revert NotAuthorized();\n        }\n\n        strategy.isActive = true;\n\n        emit StrategyResumed(delegator, strategyId);\n    }\n\n    /**\n     * @notice Delete a strategy\n     * @param delegator DeleGator address\n     * @param strategyId Strategy ID to delete\n     */\n    function deleteStrategy(address delegator, uint256 strategyId) external {\n        StrategyLibrary.Strategy storage strategy = strategies[delegator][strategyId];\n\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\n            revert StrategyNotFound();\n        }\n\n        // Authorization: Only owner or contract owner\n        if (msg.sender != strategy.owner && msg.sender != owner()) {\n            revert NotAuthorized();\n        }\n\n        // Delete strategy\n        delete strategies[delegator][strategyId];\n\n        // Remove from ID array\n        uint256[] storage ids = userStrategyIds[delegator];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (ids[i] == strategyId) {\n                ids[i] = ids[ids.length - 1];\n                ids.pop();\n                break;\n            }\n        }\n\n        userStrategyCount[delegator]--;\n\n        emit StrategyDeleted(delegator, strategyId);\n    }\n\n    /**\n     * @notice Update last rebalance time (only callable by RebalanceExecutor)\n     * @param user User address\n     * @param strategyId Strategy ID\n     */\n    function updateLastRebalanceTime(address user, uint256 strategyId) external {\n        if (msg.sender != rebalanceExecutor) {\n            revert OnlyRebalanceExecutor();\n        }\n\n        StrategyLibrary.Strategy storage strategy = strategies[user][strategyId];\n\n        if (strategy.id == 0 && strategy.tokens.length == 0) {\n            revert StrategyNotFound();\n        }\n\n        strategy.lastRebalanceTime = block.timestamp;\n\n        emit LastRebalanceTimeUpdated(user, strategyId, block.timestamp);\n    }\n\n    /**\n     * @notice Get a specific strategy\n     * @param user User address\n     * @param strategyId Strategy ID\n     * @return strategy Strategy data\n     */\n    function getStrategy(address user, uint256 strategyId)\n        external\n        view\n        returns (StrategyLibrary.Strategy memory strategy)\n    {\n        return strategies[user][strategyId];\n    }\n\n    /**\n     * @notice Get all strategy IDs for a user\n     * @param user User address\n     * @return Strategy IDs\n     */\n    function getUserStrategyIds(address user) external view returns (uint256[] memory) {\n        return userStrategyIds[user];\n    }\n\n    /**\n     * @notice Get strategy count for a user\n     * @param user User address\n     * @return count Number of strategies\n     */\n    function getUserStrategyCount(address user) external view returns (uint256 count) {\n        return userStrategyCount[user];\n    }\n\n    /**\n     * @notice Get all strategies for a user\n     * @param user User address\n     * @return Array of strategies\n     */\n    function getAllUserStrategies(address user) external view returns (StrategyLibrary.Strategy[] memory) {\n        uint256[] memory ids = userStrategyIds[user];\n        StrategyLibrary.Strategy[] memory userStrategies = new StrategyLibrary.Strategy[](ids.length);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            userStrategies[i] = strategies[user][ids[i]];\n        }\n\n        return userStrategies;\n    }\n\n    /**\n     * @notice Authorize upgrade (UUPS requirement)\n     * @param newImplementation New implementation address\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @notice Get contract version\n     * @return Version string\n     */\n    function getVersion() external pure returns (string memory) {\n        return \"1.0.0\";\n    }\n}\n","license":"MIT"},"src/delegation/types/DelegationTypes.sol":{"keccak256":"0x15a28c4f81f13119012e3e0690b601b4e1df24b956b40e44900cdfab475bf152","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n// Use MetaMask's official types from Delegation Framework\nimport { Delegation, Caveat } from \"@delegation-framework/utils/Types.sol\";\n\n/**\n * @title DelegationTypes\n * @notice Utility library for working with MetaMask DeleGator smart accounts\n * @dev Provides helper functions for DeleGator detection and ownership verification\n *\n * This library uses MetaMask's official Delegation Framework types and does not\n * implement custom delegation logic. All delegation validation and execution\n * is handled by the DelegationManager contract.\n */\nlibrary DelegationTypes {\n    /**\n     * @notice Check if address has contract code deployed\n     * @param account Address to check\n     * @return hasCode True if address has code (is a contract)\n     */\n    function isSmartContract(address account) internal view returns (bool hasCode) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @notice Check if address is a MetaMask DeleGator smart account\n     * @param account Address to check\n     * @return isDeleGatorAccount True if account is a DeleGator\n     *\n     * @dev Attempts to call owner() function which is present on HybridDeleGator\n     *      and other DeleGator implementations. If the call succeeds, it's a DeleGator.\n     */\n    function isDeleGator(address account) internal view returns (bool isDeleGatorAccount) {\n        // Must be a smart contract\n        if (!isSmartContract(account)) {\n            return false;\n        }\n\n        // Try to call owner() function (present on HybridDeleGator)\n        // Using low-level call to avoid revert if function doesn't exist\n        (bool success, bytes memory data) = account.staticcall(\n            abi.encodeWithSignature(\"owner()\")\n        );\n\n        // If call succeeded and returned data, it's likely a DeleGator\n        // HybridDeleGator.owner() returns address, which is 32 bytes\n        return success && data.length == 32;\n    }\n\n    /**\n     * @notice Get the EOA owner of a DeleGator smart account\n     * @param delegator DeleGator smart account address\n     * @return owner EOA address that owns and controls the DeleGator\n     *\n     * @dev HybridDeleGator has an owner() function that returns the EOA owner\n     *      Returns address(0) if not a DeleGator or owner() call fails\n     */\n    function getDeleGatorOwner(address delegator) internal view returns (address owner) {\n        // Validate it's a smart contract first\n        if (!isSmartContract(delegator)) {\n            return address(0);\n        }\n\n        // Try to call owner() function\n        (bool success, bytes memory data) = delegator.staticcall(\n            abi.encodeWithSignature(\"owner()\")\n        );\n\n        if (success && data.length == 32) {\n            return abi.decode(data, (address));\n        }\n\n        return address(0);\n    }\n}\n","license":"MIT"},"src/interfaces/IPythOracle.sol":{"keccak256":"0x4059b66bdd20b817bcc047c2cb6723d2fc56d3eb5152325411b79847d36b14c0","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title IPythOracle\n * @notice Interface for PythOracle wrapper contract\n */\ninterface IPythOracle {\n    // Events\n    event PriceFeedSet(address indexed token, bytes32 indexed feedId);\n    event PriceFeedRemoved(address indexed token);\n    event MaxPriceAgeUpdated(uint256 oldValue, uint256 newValue);\n    event MaxConfidenceRatioUpdated(uint256 oldValue, uint256 newValue);\n\n    // Errors\n    error NoFeedConfigured(address token);\n    error InvalidPrice(address token, int64 price);\n    error ConfidenceTooLow(uint64 conf, uint64 price, uint256 ratio);\n\n    // Configuration\n    function setPriceFeed(address token, bytes32 feedId) external;\n    function removePriceFeed(address token) external;\n    function setMaxPriceAge(uint256 seconds_) external;\n    function setMaxConfidenceRatio(uint256 bps) external;\n\n    // Price queries\n    function getPrice(address token) external view returns (uint256 price);\n    function batchGetPrices(address[] calldata tokens) external view returns (uint256[] memory prices);\n    function isPriceFresh(address token) external view returns (bool);\n\n    // Getters\n    function getVersion() external pure returns (string memory);\n    function getPythContract() external view returns (address);\n    function oracle() external view returns (address);\n    function pythContract() external view returns (address);\n    function priceFeeds(address) external view returns (bytes32);\n}\n","license":"MIT"},"src/libraries/StrategyLibrary.sol":{"keccak256":"0xbc35a0ae821b47e89d941c2e201722988bb3b992d3f034706838f6de194340f9","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IPythOracle.sol\";\n\n/**\n * @title StrategyLibrary\n * @notice Pure calculation logic for portfolio strategies (no state)\n * @dev Used by RebalanceExecutor to calculate rebalance swaps\n *\n * Non-custodial: All calculations based on user's MetaMask account balances\n */\nlibrary StrategyLibrary {\n    struct Strategy {\n        uint256 id;\n        address owner;        // EOA that owns the DeleGator smart account\n        address delegator;    // DeleGator smart account address (holds funds)\n        address[] tokens;\n        uint256[] weights;  // Basis points (100 = 1%)\n        uint256 rebalanceInterval;\n        uint256 lastRebalanceTime;\n        bool isActive;\n        string name;\n    }\n\n    error InvalidWeights();\n    error InvalidTokenCount();\n    error ZeroAddress();\n\n    /**\n     * @notice Calculate required swaps to rebalance portfolio\n     * @param account DeleGator smart account address (holds funds)\n     * @param strategy Strategy configuration\n     * @param oracle Price oracle address\n     * @return tokensToSell Tokens that need to be sold\n     * @return tokensToBuy Tokens that need to be bought\n     * @return amountsToSell Amounts to sell for each token\n     */\n    function calculateRebalanceSwaps(\n        address account,\n        Strategy memory strategy,\n        address oracle\n    )\n        external\n        view\n        returns (address[] memory tokensToSell, address[] memory tokensToBuy, uint256[] memory amountsToSell)\n    {\n        require(account != address(0), \"Invalid account\");\n        require(oracle != address(0), \"Invalid oracle\");\n\n        // Get current balances from user's account\n        uint256[] memory balances = new uint256[](strategy.tokens.length);\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\n            balances[i] = IERC20(strategy.tokens[i]).balanceOf(account);\n        }\n\n        // Get current prices\n        uint256[] memory prices = IPythOracle(oracle).batchGetPrices(strategy.tokens);\n\n        // Calculate total portfolio value\n        uint256 totalValueUSD = 0;\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\n            // Adjust for token decimals\n            uint8 decimals = IERC20Metadata(strategy.tokens[i]).decimals();\n            uint256 valueUSD = (balances[i] * prices[i]) / (10 ** decimals);\n            totalValueUSD += valueUSD;\n        }\n\n        // Calculate target values for each token\n        uint256[] memory targetValuesUSD = new uint256[](strategy.tokens.length);\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\n            targetValuesUSD[i] = (totalValueUSD * strategy.weights[i]) / 10000;\n        }\n\n        // Calculate current values for each token\n        uint256[] memory currentValuesUSD = new uint256[](strategy.tokens.length);\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\n            uint8 decimals = IERC20Metadata(strategy.tokens[i]).decimals();\n            currentValuesUSD[i] = (balances[i] * prices[i]) / (10 ** decimals);\n        }\n\n        // Determine which tokens to sell and buy\n        uint256 sellCount = 0;\n        uint256 buyCount = 0;\n\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\n            if (currentValuesUSD[i] > targetValuesUSD[i]) {\n                sellCount++;\n            } else if (currentValuesUSD[i] < targetValuesUSD[i]) {\n                buyCount++;\n            }\n        }\n\n        tokensToSell = new address[](sellCount);\n        tokensToBuy = new address[](buyCount);\n        amountsToSell = new uint256[](sellCount);\n\n        uint256 sellIndex = 0;\n        uint256 buyIndex = 0;\n\n        for (uint256 i = 0; i < strategy.tokens.length; i++) {\n            if (currentValuesUSD[i] > targetValuesUSD[i]) {\n                tokensToSell[sellIndex] = strategy.tokens[i];\n\n                // Calculate amount to sell (in token units)\n                uint256 excessValueUSD = currentValuesUSD[i] - targetValuesUSD[i];\n                uint8 decimals = IERC20Metadata(strategy.tokens[i]).decimals();\n                amountsToSell[sellIndex] = (excessValueUSD * (10 ** decimals)) / prices[i];\n\n                sellIndex++;\n            } else if (currentValuesUSD[i] < targetValuesUSD[i]) {\n                tokensToBuy[buyIndex] = strategy.tokens[i];\n                buyIndex++;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate current allocation weights\n     * @param account DeleGator smart account address (holds funds)\n     * @param tokens Token addresses\n     * @param oracle Price oracle address\n     * @return weights Current weights in basis points\n     */\n    function calculateCurrentWeights(address account, address[] memory tokens, address oracle)\n        external\n        view\n        returns (uint256[] memory weights)\n    {\n        require(account != address(0), \"Invalid account\");\n        require(oracle != address(0), \"Invalid oracle\");\n\n        uint256[] memory balances = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            balances[i] = IERC20(tokens[i]).balanceOf(account);\n        }\n\n        uint256[] memory prices = IPythOracle(oracle).batchGetPrices(tokens);\n\n        uint256 totalValueUSD = 0;\n        uint256[] memory valuesUSD = new uint256[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint8 decimals = IERC20Metadata(tokens[i]).decimals();\n            valuesUSD[i] = (balances[i] * prices[i]) / (10 ** decimals);\n            totalValueUSD += valuesUSD[i];\n        }\n\n        weights = new uint256[](tokens.length);\n        if (totalValueUSD == 0) {\n            return weights; // All zeros if no balance\n        }\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            weights[i] = (valuesUSD[i] * 10000) / totalValueUSD;\n        }\n    }\n\n    /**\n     * @notice Calculate drift between current and target weights\n     * @param currentWeights Current allocation in basis points\n     * @param targetWeights Target allocation in basis points\n     * @return drift Maximum deviation in basis points\n     */\n    function calculateDrift(uint256[] memory currentWeights, uint256[] memory targetWeights)\n        external\n        pure\n        returns (uint256 drift)\n    {\n        require(currentWeights.length == targetWeights.length, \"Length mismatch\");\n\n        drift = 0;\n        for (uint256 i = 0; i < currentWeights.length; i++) {\n            uint256 deviation = currentWeights[i] > targetWeights[i]\n                ? currentWeights[i] - targetWeights[i]\n                : targetWeights[i] - currentWeights[i];\n\n            if (deviation > drift) {\n                drift = deviation;\n            }\n        }\n    }\n\n    /**\n     * @notice Get total portfolio value in USD\n     * @param account DeleGator smart account address (holds funds)\n     * @param tokens Token addresses\n     * @param oracle Price oracle address\n     * @return totalValueUSD Portfolio value scaled to 18 decimals\n     */\n    function getPortfolioValue(address account, address[] memory tokens, address oracle)\n        external\n        view\n        returns (uint256 totalValueUSD)\n    {\n        require(account != address(0), \"Invalid account\");\n        require(oracle != address(0), \"Invalid oracle\");\n\n        uint256[] memory balances = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            balances[i] = IERC20(tokens[i]).balanceOf(account);\n        }\n\n        uint256[] memory prices = IPythOracle(oracle).batchGetPrices(tokens);\n\n        totalValueUSD = 0;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint8 decimals = IERC20Metadata(tokens[i]).decimals();\n            uint256 valueUSD = (balances[i] * prices[i]) / (10 ** decimals);\n            totalValueUSD += valueUSD;\n        }\n    }\n\n    /**\n     * @notice Validate strategy parameters\n     * @param tokens Token addresses\n     * @param weights Token weights in basis points\n     */\n    function validateStrategy(address[] memory tokens, uint256[] memory weights) external pure {\n        if (tokens.length == 0 || tokens.length > 10) {\n            revert InvalidTokenCount();\n        }\n\n        if (tokens.length != weights.length) {\n            revert InvalidTokenCount();\n        }\n\n        // Check no zero addresses\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (tokens[i] == address(0)) {\n                revert ZeroAddress();\n            }\n        }\n\n        // Check weights sum to 10000 (100%)\n        uint256 totalWeight = 0;\n        for (uint256 i = 0; i < weights.length; i++) {\n            totalWeight += weights[i];\n        }\n\n        if (totalWeight != 10000) {\n            revert InvalidWeights();\n        }\n    }\n}\n","license":"MIT"}},"version":1},"id":82}